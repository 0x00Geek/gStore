\documentclass[titlepage, a4paper, 12pt]{article}

\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{amssymb}
\usepackage{times}
\usepackage{graphicx}
\usepackage{epsfig,tabularx,amssymb,amsmath,subfigure,multirow}
%\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,noend]{algorithm2e}
\usepackage[noend]{algorithmic}
\usepackage{multirow}
\usepackage{graphicx,floatrow}
\usepackage{listings}
\usepackage{threeparttable}
%\usepackage{tikz}
\usepackage[T1]{fontenc}
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{comment}

\lstset{%
	alsolanguage=Java,
	%language={[ISO]C++},       %language 为，还有{[Visual]C++}
	%alsolanguage=[ANSI]C,      %可以添加很多个alsolanguage,如alsolanguage=matlab,alsolanguage=VHDL等
	%alsolanguage= tcl,
	alsolanguage= XML,
	tabsize=4, %
	frame=shadowbox, %把代码用带有阴影的框圈起来
	commentstyle=\color{red!50!green!50!blue!50},% 浅灰色的注释
	rulesepcolor=\color{red!20!green!20!blue!20},% 代码块边框为淡青色
	keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体
	showstringspaces=false,%不显示代码字符串中间的空格标记
	stringstyle=\ttfamily, % 代码字符串的特殊格式
	keepspaces=true, %
	breakindent=22pt, %
	numbers=left,%左侧显示行号 往左靠,还可以为right，或none，即不加行号
	stepnumber=1,%若设置为2，则显示行号为1,3,5，即stepnumber为公差,默认stepnumber=1
	%numberstyle=\tiny, %行号字体用小号
	numberstyle={\color[RGB]{0,192,192}\tiny} ,%设置行号的大小，大小有tiny,scriptsize,footnotesize,small,normalsize,large 等
	numbersep=8pt,  %设置行号与代码的距离，默认是5pt
	basicstyle=\footnotesize, % 这句设置代码的大小
	showspaces=false, %
	flexiblecolumns=true, %
	breaklines=true, %对过长的代码自动换行
	breakautoindent=true,%
	breakindent=4em, %
	%	escapebegin=\begin{CJK*}{GBK}{hei},escapeend=\end{CJK*},
	aboveskip=1em, %代码块边框
	tabsize=2,
	showstringspaces=false, %不显示字符串中的空格
	backgroundcolor=\color[RGB]{245,245,244},   %代码背景色
	%backgroundcolor=\color[rgb]{0.91,0.91,0.91}    %添加背景色
	escapeinside=``,  %在``里显示中文
	%% added by http://bbs.ctex.org/viewthread.php?tid=53451
	fontadjust,
	captionpos=t,
	framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,
	xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白
	texcl=true,
	% 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式
	extendedchars=false,columns=flexible,mathescape=true
	% numbersep=-1em
}

\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{?}
\fi

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage{longtable,booktabs}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi



\usepackage{ctex}


\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Gstore System},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
%\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
\setlength{\parindent}{0pt}
%\setlength{\parindent}{2em}
\addtolength{\parskip}{3pt}
\linespread{1.3}

%BETTER:设置各种字体
%\setmainfont[BoldFont=黑体]{宋体}               % 使用系统默认字体
\XeTeXlinebreaklocale "zh"                      % 针对中文进行断行
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt  % 给予TeX断行一定自由度
\makeatletter
\let\@afterindentfalse\@afterindenttrue
\@afterindenttrue
\makeatother
\setlength{\parindent}{2em}
\addtolength{\parskip}{3pt}
\linespread{1.3} %一倍半行距
%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%\usepackage{CJKutf8}
\usepackage{xeCJK}
%\setCJKmainfont{SimSun}
\CJKsetecglue{\,}

\begin{document}
\title{\includegraphics[scale=0.3, bb=0 0 385 567]{logo.png} \\
	gStore系统使用手册}
%\author{Bookug Lobert\footnote{EECS of Peking University, zengli-bookug@pku.edu.cn}\\[2ex]}
\author{由gStore团队编写 \footnote{邮箱列表在第11章中给出。}}
\date{\today}
%\begin{figure}[b]
%	\centering
%　	\includegraphics[scale=0.3,bb=0 0 385 567]{../logo.png}
	%\caption{Some description about the picture}
%	\label{logo}
%\end{figure}
\maketitle

\hyperdef{}{MathJaxux5fSVGux5fHidden}{}

\hyperdef{}{wmd-preview}{}

\setcounter{tocdepth}{4}
\tableofcontents
\clearpage

\section{前言}
RDF（\emph{R}esource \emph{D}escription \emph{F}ramework，资源描述框架）是由W3C提出的一组标记语言的技术规范，用来表现万维网上各类资源的信息并发展语义网络。在RDF模型中，每个网络对象都由一个唯一命名的资源来表示，用一个URI（\emph{U}niform \emph{R}esource \emph{I}dentifier，统一资源标识符）来标识。RDF也利用URI去命名资源的属性和资源间的关系，以及关系的两端（通常被称为“三元组”）。因此，一个RDF数据集可以由一个有向、有标签的图来表示，其中资源是顶点，三元组是标签为属性或关系的边。更多的细节请参阅\href{https://www.w3.org/RDF/}{RDF 介绍}。

%The RDF (\emph{R}esource \emph{D}escription \emph{F}ramework) is a family of specifications proposed by W3C for modeling Web objects as part of developing the semantic web. In RDF model, each Web object is modeled as a uniquely named \emph{resource} and denoted by a URI (\emph{U}niform \emph{R}esource \emph{I}dentifier). RDF also uses URIs to name the properties of resources and the relationships between resources as well as the two ends of the link (this is usually referred to as a ``triple''). Hence, an RDF dataset can be represented as a directed, labeled graph where resources are vertices, and triples are edges with property or relationship names as edge labels. For more details, please go to \href{https://www.w3.org/RDF/}{RDF Introduction}\\

为了检索并操控一个RDF图，W3C提供了一种结构化的查询语言，SPARQL (\emph{S}imple \emph{P}rotocol \emph{A}nd \emph{R}DF \emph{Q}uery \emph{L}anguage，简单协议和RDF查询语言)。SPARQL能够依据连接或分离关系，查询指定图模式和可选图模式。SPARQL同时支持聚集函数、子查询、否定查询、根据表达式创造值、可扩展的值检验、根据源RDF的限制性查询。与RDF图类似，SPARQL查询可以表示为有若干变量的查询图。这样一来，回答一个SPARQL 查询就等价于在一个RDF图中找到一个匹配查询的子图。通过\href{https://www.w3.org/TR/sparql11-query/}{SPARQL 介绍}了解有关SPARQL的更多信息。

%To retrieve and manipulate an RDF graph, W3C also proposes a structured query language, SPARQL (\emph{S}imple \emph{P}rotocol \emph{A}nd \emph{R}DF \emph{Q}uery \emph{L}anguage), to access RDF repository. SPARQL contains capabilities for querying required and optional graph patterns along with their conjunctions and disjunctions. SPARQL also supports aggregation, subqueries, negation, creating values by expressions, extensible value testing, and constraining queries by source RDF graph. Similar to RDF graphs, a SPARQL query can also be modeled as a graph, which is a query graph with some variables. Then, evaluating a SPARQL query is equivalent to finding subgraph (homomorphism) matches of a query graph over an RDF graph. You can have a better understanding of SPARQL at \href{https://www.w3.org/TR/sparql11-query/}{SPARQL Introduction}.\\

虽然有一些RDF数据管理系统（例如Jena、Virtuoso、Sesame）在关系系统中储存RDF数据，但现有的系统几乎都没有开发符合SPARQL语义的图模式。\textbf{在这里我们完善了基于图的RDF 三元组存储，称为gStore，是北京大学、滑铁卢大学、香港科技大学的联合研究项目。中国北京大学计算机科学与技术研究所的数据库组对该系统进行开发和维护。}对于gStore的详细描述可以在\hyperref[chapter07]{【出版物】}一章我们的论文{[}Zou et al., VLDB 11{]}和{[}Zou et al., VLDB Journal 14{]}中找到。这份帮助文档包括系统安装、使用、API、 用例和FAQ。gStore是github上遵循BSD协议的一个开源项目。你可以使用gStore、报告问题、提出建议，或加入我们使gStore变得更好。你也可以在尊重我们的工作的基础上基于gStore开发各种应用。
%Although there are some RDF data management systems (like Jena, Virtuoso, Sesame) that store the RDF data in relational systems, few existing systems exploit the native graph pattern matching semantics of SPARQL. \textbf{Here, we implement a graph-based RDF triple store named gStore, which is a joint research project by Peking University, University of Waterloo and Hong Kong University of Science and Technology. The system is developed and maintained by the database group in Institute of Computer Science and Technology, Peking University, China.} A detailed description of gStore can be found at our papers {[}Zou et al., VLDB 11{]} and {[}Zou et al., VLDB Journal 14{]} in the \hyperref[chapter07]{Publication} chapter. This HELP document includes system installment, usage, API, use cases and FAQ. gStore is a open-source project in github under the BSD license. You are welcome to use gStore, report bugs or suggestions, or join us to make gStore better. It is also allowed for you to build all kinds of applications based on gStore, while respecting our work.\\

\textbf{请确保在使用gStore之前已经阅读了\hyperref[chapter16]{【法律问题】}一章。}

%\textbf{Please make sure that you have read \hyperref[chapter16]{Legal Issues} before using gStore.}

\clearpage

\part{开始}

\hyperdef{}{charpter00}{\subsection{第00章: 快速导览}\label{chapter00}}

Gstore系统（也称作gStore）是一个用于管理大型图结构数据的图数据库引擎，是一个针对Linux操作系统的开源软件。整个项目用C++编写，使用了一些库，例如readline、antlr等等。目前只提供了源代码，也就是说要使用我们的系统，你必须对源码进行编译。
%Gstore System(also called gStore) is a graph database engine for managing large graph-structured data, which is open-source and targets at Linux operation systems. The whole project is written in C++, with the help of some libraries such as readline, antlr, and so on. Only source tarballs are provided currently, which means you have to compile the source code if you want to use our system.

\hyperdef{}{getting-started}{\subsubsection{开始使用}\label{getting-started}}

本系统接口对用户友好，你可以在几分钟内学会使用。请在\hyperref[chapter01]{【系统要求】}一章中检查你想要运行这一系统的平台。在确认后，获取项目的源码。有以下几种方法：
%This system is really user-friendly and you can pick it up in several minutes. Remember to check your platform where you want to run this system by viewing \hyperref[chapter01]{System Requirements}. After all are verified, please get this project's source code. There are several ways to do this:

\begin{itemize}
\item
  在这个库中下载zip文件并进行解压
  %download the zip from this repository and extract it
\item
  使用你的github账号Fork这个库
  %fork this repository in your github account
\item
  在你的终端输入\texttt{git\ clone\ git@github.com:Caesar11/gStore.git}或使用git GUI获得
  %type \texttt{git\ clone\ git@github.com:Caesar11/gStore.git} in your terminal or use git GUI to acquire it
\end{itemize}

之后你需要对这个项目进行编译，只要在gStore 根目录下输入\texttt{make}，所有可执行程序就可以运行了。要运行gStore，请输入\texttt{bin/gload\ database\_name\ dataset\_path}生成一个你自己命名的数据库。你可以用\texttt{bin/gquery\ database\_name}这一命令查询一个已存在的数据库。此外，\texttt{bin/gconsole}是一个非常好的工具，提供了你使用gStore需要的所有操作。
%Then you need to compile the project, just type \texttt{make} in the gStore root directory, and all executables will be ok. To run gStore, please type \texttt{bin/gload\ database\_name\ dataset\_path} to build a database named by yourself. And you can use \texttt{bin/gquery\ database\_name} command to query a existing database. What is more, \texttt{bin/gconsole} is a wonderful tool designed for you, providing all operations you need to use gStore.
请注意，所有的命令都应该在gStore根目录下输入。
%Notice that all commands should be typed in the root directory of gStore.

\emph{你可以在本文档的第04章\hyperref[chapter04]{【如何使用】}一章中找到详细描述。}

%\emph{A detailed description can be found at Chapter 04 \hyperref[chapter04]{How to use} in this document.}

\hyperdef{}{advanced-help}{\subsubsection{高级帮助}\label{advanced-help}}
%\hyperdef{}{advanced-help}{\subsubsection{Advanced Help}\label{advanced-help}}

如果你希望理解gStore系统的细节，或是尝试一些高级操作（例如，使用API、服务器/客户端），请参阅以下章节。
%If you want to understand the details of the gStore system, or you want to try some advanced operations(for example, using the API, server/client), please see the chapters below.

\begin{itemize}
\item
  \hyperref[chapter02]{【基本介绍】}：介绍gStore的原理和特征
  %\hyperref[chapter02]{Basic Introduction}: introduce the theory and features of gStore
\item
  \hyperref[chapter03]{【安装指南】}：安装系统的指令
  %\hyperref[chapter03]{Install Guide}: instructions on how to install this system
\item
  \hyperref[chapter04]{【如何使用】}：使用gStore系统的详细指导
  %\hyperref[chapter04]{How To Use}: detailed information about using the gStore system
\item
  \hyperref[chapter05]{【API说明】}：基于gStore API开发应用
  %\hyperref[chapter05]{API Explanation}: guide you to develop applications based on our API
\item
  \hyperref[chapter06]{【项目结构】}：展现本项目的结构和流程
  %\hyperref[chapter06]{Project Structure}: show the whole structure and sequence of this project
\item
  \hyperref[chapter07]{【出版物】}：与gStore相关的论文和出版物
  %\hyperref[chapter07]{Publications}: contain essays and publications
  %related with gStore
\item
  \hyperref[chapter12]{【更新日志】}：保存了系统更新的日志
  %\hyperref[chapter12]{Update Logs}: keep the logs of the system updates
\item
  \hyperref[chapter13]{【测试结果】}：展现一系列的实验结果
  %\hyperref[chapter13]{Test Result}: present the test results of a series of experiments
\end{itemize}

\hyperdef{}{other-business}{\subsubsection{其他事项}\label{other-business}}
%\hyperdef{}{other-business}{\subsubsection{Other Business}\label{other-business}}

在\hyperref[chapter10]{【技巧】}一章中，我们撰写了一系列短文，解决使用gStore来实现应用时出现的常见问题。
%We have written a series of short essays addressing recurring challenges in using gStore to realize applications, which are placed in \hyperref[chapter10]{Recipe Book}.

如果不需要及时回复，你可以在这个库的Issues 部分报告建议或错误。如果你急于联系我们处理你的报告，请通过电子邮件提交你的建议和错误报告。我们团队的完整列表在\hyperref[chapter11]{【贡献者】}一章中给出。
%You are welcome to report any advice or errors in the github Issues part of this repository, if not requiring in-time reply. However, if you want to urgent on us to deal with your reports, please email to to submit your suggestions and report bugs to us by emailing to . A full list of our whole team is in \hyperref[chapter11]{Contributors}.

使用现有的gStore系统有一些限制，你可以在\hyperref[chapter08]{【限制】}一章中看到。
%There are some restrictions when you use the current gStore project, you can see them on \hyperref[chapter08]{Limitations}.

有时候你可能会发现一些奇怪的现象（但不是错误案例），或者很难理解/解决（不知道接下来怎么做），可以参阅\hyperref[chapter09]{【FAQ】}。
%Sometimes you may find some strange phenomena(but not wrong case), or something hard to understand/solve(don't know how to do next), then do not hesitate to visit the \hyperref[chapter09]{Frequently Asked Questions} page.

图数据库引擎是一个新的领域，我们还在努力发展。我们接下来要做的事在\hyperref[chapter14]{【将来计划】}一章中列出，我们希望越来越多的人可以支持甚至加入我们。你可以通过很多方法支持我们：
%Graph database engine is a new area and we are still trying to go further. Things we plan to do next is in \hyperref[chapter14]{Future Plan} chapter, and we hope more and more people will support or even join us. You can support in many ways:

\begin{itemize}
\item
  watch/star我们的项目
  %watch/star our project
\item
  fork这个库，向我们提交pull请求
  %fork this repository and submit pull requests to us
\item
  下载并使用这一系统，报告错误或建议
  %download and use this system, report bugs or suggestions
\item
  \ldots{}
\end{itemize}

启发我们或对这个项目做出贡献的人会在\hyperref[chapter15]{【致谢列表】}中列出。
%People who inspire us or contribute to this project will be listed in the \hyperref[chapter15]{Thanks List} chapter.

\clearpage

\hyperdef{}{chapter01}{\subsection{第01章：系统要求}\label{chapter01}}
%\hyperdef{}{chapter01}{\subsection{Chapter 01: System Requirements}\label{chapter01}}

\emph{我们已经在linux CentOs 6.2 x86\_64和CentOS 6.6 x86\_64系统做了测试。GCC版本应该为4.47或更高。}
%\emph{We have tested on linux server with CentOS 6.2 x86\_64 and CentOS 6.6 x86\_64. The version of GCC should be 4.4.7 or later.}

\begin{longtable}[c]{@{}ll@{}}
\toprule
项目 & 要求\tabularnewline
\midrule
\endhead
操作系统 & Linux，例如CentOS，Ubuntu等等\tabularnewline
%operation system & Linux, such as CentOS, Ubuntu and so on\tabularnewline
架构 & x86\_64\tabularnewline
%architecture & x86\_64\tabularnewline
磁盘容量 & 取决于数据集大小\tabularnewline
%disk size & according to size of dataset\tabularnewline
内存空间 & 取决于数据集大小\tabularnewline
%memory size & according to size of dataset\tabularnewline
glibc & 版本 \textgreater{}= 2.14\tabularnewline
%glibc & version \textgreater{}= 2.14\tabularnewline
gcc & 版本 \textgreater{}= 4.4.7\tabularnewline
%gcc & version \textgreater{}= 4.4.7\tabularnewline
g++ & 版本 \textgreater{}= 4.4.7\tabularnewline
%g++ & version \textgreater{}= 4.4.7\tabularnewline
make & 需要安装\tabularnewline
%make & need to be installed\tabularnewline
readline & 需要安装\tabularnewline
%readline & need to be installed\tabularnewline
readline-devel & 需要安装\tabularnewline
%readline-devel & need to be installed\tabularnewline
openjdk & 使用Java api时需要\tabularnewline
%openjdk & needed if using Java api\tabularnewline
openjdk-devel & 使用Java api时需要\tabularnewline
%openjdk-devel & needed if using Java api\tabularnewline
realpath & 使用gconsole时需要\tabularnewline
%realpath & needed if using gconsole\tabularnewline
\bottomrule
\caption{软件要求}
\end{longtable}

注意事项：
%NOTICE:

\begin{enumerate}
\item
  一些包的名字可能在不同平台上有所不同，只需要安装你自己的操作平台所对应的包
  %The name of some packages may be different in different platforms, just install the corresponding one in your own operation system.
\item
  要安装readline和readline-devel，只需要在Redhat/CentOS/Fedora中输入\texttt{dnf\ install\ readline-devel}，或者在Debian/Ubuntu 中输入\texttt{apt-get\ install\ libreadline-dev}。请在其他系统中使用对应的指令。如果你使用的是ArchLinux，只要输入\texttt{pacman\ -S\ readline}就可以安装readline和readline-devel。（其他包也一样）
  %To install readline and readline-devel, just type \texttt{dnf\ install\ readline-devel} in Redhat/CentOS/Fedora, or \texttt{apt-get\ install\ libreadline-dev} in Debian/Ubuntu. Please use corresponding commands in other systems. If you use ArchLinux, just type \texttt{pacman\ -S\ readline} to install the readline and readline-devel.(so do other packages)
\item
  使用gStore不需要安装realpath，但如果你想要使用gconsole，请输入\texttt{dnf\ install\ realpath}或\texttt{apt-get\ install\ realpath}进行安装。
  %You do not have to install realpath to use gStore, but if you want to use the gconsole for its convenience, please do so by using \texttt{dnf\ install\ realpath} or \texttt{apt-get\ install\ realpath}.
\item
  我们的项目使用了正则表达式，由GNU/Linux默认提供。要使用更强大的正则表达式库，你不需要安装boost和boost-devel。
  %Our programs use regEx functions, which are provided by GNU/Linux by default. You do not need to have to install boost and boost-devel for more powerful regEx libraries.
\item
  gStore使用了ANTLR3.4生成SPARQL查询的语法分析代码。你不需要安装相应的antlr 库，因为我们已经将libantlr3.4融入系统中。
  %ANTLR3.4 is used in gStore to produce lexer and parser code for SPARQL query. However, you do not need to install the corresponding antlr libraries because we have merged the libantlr3.4 in our system.
\item
  当你在gStore项目的根目录下输入\texttt{make}时，Java api也会编译。如果你的系统里没有JDK，你可以修改makefile。我们建议你在Linux系统中安装openjdk-devel。
  %When you type \texttt{make} in the root directory of the gStore project, the Java api will also be compiled. You can modify the makefile if you do not have JDK in your system. However, you are advised to install openjdk-devel in your Linux system.
\item
  其他问题请参阅\hyperref[chapter09]{【FAQ】}一章。
  %Any other questions, please go to \hyperref[chapter09]{FAQ} page.
\end{enumerate}

\clearpage

\hyperdef{}{chapter02}{\subsection{第02章：基本介绍}\label{chapter02}}

\textit{与Gstore系统相关的第一篇论文是\href{run:../pdf/gStoreVLDBJ.pdf}{gStore\_VLDBJ}，你可以在\hyperref[chapter07]{【出版物】}一章中找到相关出版物。}
%\textit{The first essay to come up with Gstore System is \href{run:../pdf/gStoreVLDBJ.pdf}{gStore\_VLDBJ}, and you can find related publications in \hyperref[chapter07]{Publications}.}

\hyperdef{}{what-is-gstore}{\subsubsection{什么是gStore}\label{what-is-gstore}}
%\hyperdef{}{what-is-gstore}{\subsubsection{What Is gStore}\label{what-is-gstore}}

gStore是一个基于图的RDF数据管理系统（也称为“三元组存储”），维持了原始\href{http://www.w3.org/TR/rdf11-concepts/}{RDF} 数据的图结构。它的数据模型是有标签的有向多边图，每个顶点对应一个主体或客体。
%gStore is a graph-based RDF data management system(or what is commonly called a ``triple store'') that maintains the graph structure of the original \href{http://www.w3.org/TR/rdf11-concepts/}{RDF} data. Its data model is a labeled, directed multi edge graph, where each vertex corresponds to a subject or an object.

我们用查询图Q来表示给出的\href{http://www.w3.org/TR/sparql11-overview/}{SPARQL}。 查询过程涉及查找在RDF图G中与Q匹配的子图，而不是在关系型数据库中将表连接到一起。gStore包含一个RDF图的指针（称为VS树）来加快查询过程。VS树是一个深度平衡树，使用了大量裁减算法加快子图匹配。
%We represent a given \href{http://www.w3.org/TR/sparql11-overview/}{SPARQL} query by a query graph Q. Query processing involves finding subgraph matches of Q over the RDF graph G, instead of joining tables in relational data management system. gStore incorporates an index over the RDF graph (called VS-tree) to speed up query processing. VS-tree is a height balanced tree with a number of associated pruning techniques to speed up subgraph matching.

\textbf{gStore项目获得中国国家自然科学基金（NSFC）、加拿大自然科学和工程研究委员会（NSERC）和香港RGC支持。}
%\textbf{The gStore project is supported by the National Science Foundation of China (NSFC), Natural Sciences and Engineering Research Council (NSERC) of Canada, and Hong Kong RGC.}

\hyperdef{}{why-gstore}{\subsubsection{为什么选择gStore}\label{why-gstore}}
%\hyperdef{}{why-gstore}{\subsubsection{Why gStore}\label{why-gstore}}

在一系列测试后，我们进行了分析并将结果记录在\hyperref[chapter13]{【测试结果】}一章中。gStore在回答复杂查询时（例如，包含循环）比其他数据库系统运行更快。对于简单查询，gStore和其他数据库系统都运行得很好。
%After a series of test, we analyse and keep the result in \hyperref[chapter13]{Test Results}. gStore runs faster to answer complicated queries(for example, contain circles) than other database systems. For simple queries, both gStore and other database systems work well.

另外，当今是大数据时代，出现了越来越多的结构化数据，原来的关系型数据库系统（或是基于关系表的数据库系统）不能高效地处理结构化数据。相反，gStore可以利用图数据结构的特征并提升性能。
%In addition, now is the big data era and more and more structured data is coming, while the original relational database systems(or database systems based on relational tables) cannot deal with them efficiently.  In contrast, gStore can utilize the features of graph data structures, and improve the performance.

此外，gStore是一个高扩展性项目。很多关于图数据库的新想法被提出，大多数都可以在gStore 中使用。例如，我们组也在设计一个分布型gstore 系统，有望在2016年年底发布。
%What is more, gStore is a high-extensible project. Many new ideas of graph database have be proposed, and most of them can be used in gStore.  For example, our group is also designing a distributed gstore system, which is expected to be released at the end of 2016.

\hyperdef{}{open-source}{\subsubsection{开源与授权}\label{open-source}}
%\hyperdef{}{open-source}{\subsubsection{Open Source}\label{open-source}}

gStore的源代码遵循BSD开源协议。你可以使用gStore、报告建议或问题，或者加入我们使gStore变得更好。在尊重我们的工作的前提下，你也可以基于gStore 开发各种应用。
%The gStore source code is available as open-source code under the BSD license. You are welcome to use gStore, report bugs or suggestions, or join us to make gStore better. It is also allowed for you to build all kinds of applications based on gStore, while respecting our work.

\clearpage

\hyperdef{}{chapter03}{\subsection{第03章：安装指南}\label{chapter03}}
%\hyperdef{}{chapter03}{\subsection{Chapter 03: Install Guide}\label{chapter03}}

gStore是一个绿色软件，你只需要用一个指令对它进行编译。请在gStore根目录下运行\texttt{make}来编译gStore代码，连接ANTLR 库，并生成可执行的``gload''、``gquery''、``gserver''、``gclient''、``gconsole''。 另外，gStore的api也在此时生成。
%gStore is a green software, and you just need to compile it with one command. Please run \texttt{make} in the gStore root directory to compile the gStore code, link the ANTLR lib, and build executable ``gload'', ``gquery'', ``gserver'', ``gclient'', ``gconsole''. What is more, the api of gStore is also built now.

如果你想使用gStore的API样例，请运行\texttt{make\ APIexample}编译C++ API和Java API的样例代码。关于API的更多细节，请参阅\hyperref[chapter05]{【API】}一章。
%If you want to use API examples of gStore, please run \texttt{make\ APIexample} to compile example codes for both C++ API and Java API. For details of API, please visit \hyperref[chapter05]{API} chapter.

使用\texttt{make\ clean}指令清除所有对象、可执行程序，使用\texttt{make\ dist}指令清除gStore根目录下的所有对象、可执行程序、库、数据集、数据库、调试日志和临时/文本文件。
%Use \texttt{make\ clean} command to clean all objects, executables, and use \texttt{make\ dist} command to clean all objects, executables, libs, datasets, databases, debug logs, temp/text files in the gStore root directory.

你可以自由修改gStore的源代码，在尊重我们工作的基础上开发自己的项目，输入\texttt{make\ tarball}指令将所有有用的文件压缩成.tar.gz 文件，易于传输。
%You are free to modify the source code of gStore and create your own project while respecting our work, and type \texttt{make\ tarball} command to compress all useful files into a .tar.gz file, which is easy to carry.

如果你想使用测试工具，输入\texttt{make\ gtest}编译gtest程序。你可以在\hyperref[chapter04]{【如何使用】}一章中看到关于gtest 程序的更多细节。
%Type \texttt{make\ gtest} to compile the gtest program if you want to use this test utility. You can see the \hyperref[chapter04]{HOW TO USE} for details of gtest program.

\clearpage

\hyperdef{}{chapter04}{\subsection{第04章：如何使用}\label{chapter04}}
%\hyperdef{}{chapter04}{\subsection{Chapter 04: How To Use}\label{chapter04}}

\textit{gStore目前包含五个可执行程序和其他文件。}
%\textit{gStore currently includes five executables and others.}

\textbf{gStore的所有指令都应该在gStore根目录下使用，例如bin/gconsole。因为所有的可指行程序都在bin/中，它们可以使用了一些文件，其路径在代码中声明，但不是绝对路径。我们之后会让使用者给出他们系统中安装/配置gStore 的绝对路径，以确保所有的路径都是绝对的。然而，现在你必须这么做以避免错误。}
%\textbf{All the commands of gStore should be used in the root directory of gStore like bin/gconsole, because executables are placed in bin/, and they may use some files whose paths are indicated in the code, not absolute paths. We will ensure that all paths are absolute later by asking users to give the absolute path in their own systems to really install/configure the gStore. However, you must do as we told now to avoid errors.}

\hyperdef{}{0-gconsole}{\paragraph{0. gconsole}\label{0-gconsole}}

gconsole是gStore的主要控制台，与其他函数和一些系统指令整合对gStore进行操作。提供了完整的命令名称、命令行编辑特征、可以获取历史命令。尝试gconsole将是一次奇妙之旅！（空格或制表符可以在开头或结尾使用，不需要输入任何特殊字符作为分隔符）
%gconsole is the main console of gStore, which integrates with all functions to operate on gStore, as well as some system commands.  Completion of commands name, line editing features and access to the history list are all provided. Feel free to try it, and you may have a wonderful tour!(spaces or tabs at the beginning or end is ok, and no need to type any special characters as separators)

%Gstore控制台（gconsole），一个用于与gStore库通讯的基于shell的交互式应用。
\begin{verbatim}
[bookug@localhost gStore]$ bin/gconsole
Gstore Console(gconsole), an interactive shell based utility to communicate with gStore repositories.
usage: start-gconsole [OPTION]
-h,--help              print this help
-s,--source            source the SPARQL script
For bug reports and suggestions, see https://github.com/Caesar11/gStore

notice that commands are a little different between native mode and remote mode!
now is in native mode, please type your commands.
please do not use any separators in the end.

gstore>help

gstore>help drop
drop            Drop a database according to the given path.

gstore>connect 127.0.0.1 3305
now is in remote mode, please type your commands.

server>disconnect
now is in native mode, please type your commands.

gstore>build lubm_10 ./data/LUBM_10.n3
...
import RDF file to database done.

gstore>unload

gstore>load lubm_10
...
database loaded successfully!

gstore>show
lubm_10.db

gstore>query ./data/LUBM_q0.sql
...
final result is :
?x
<http://www.Department0.University0.edu/FullProfessor0>
<http://www.Department1.University0.edu/FullProfessor0>
<http://www.Department2.University0.edu/FullProfessor0>
<http://www.Department3.University0.edu/FullProfessor0>
<http://www.Department4.University0.edu/FullProfessor0>
<http://www.Department5.University0.edu/FullProfessor0>
<http://www.Department6.University0.edu/FullProfessor0>
<http://www.Department7.University0.edu/FullProfessor0>
<http://www.Department8.University0.edu/FullProfessor0>
<http://www.Department9.University0.edu/FullProfessor0>
<http://www.Department10.University0.edu/FullProfessor0>
<http://www.Department11.University0.edu/FullProfessor0>
<http://www.Department12.University0.edu/FullProfessor0>
<http://www.Department13.University0.edu/FullProfessor0>
<http://www.Department14.University0.edu/FullProfessor0>

gstore>query "select distinct ?x ?y where { ?x <rdf:type>
<ub:UndergraduateStudent> .
?x <ub:takesCourse> ?y . ?y <ub:name> <FullProfessor1> . }"
final result is :
?x      ?y
[empty result]

gstore>unload

gstore>quit
\end{verbatim}

在gStore根目录输入\texttt{bin/gconsole}来使用控制台，你会发现\texttt{gstore\textgreater{}}提示，意味着你处于本机模式并可以输入本机命令。控制台还有另一种模式，称为远程模式。在本机模式下输入\texttt{connect}进入远程模式，输入\texttt{disconnect}退回到本机模式。（控制台连接到gStore服务器，其ip为`127.0.0.1'，端口号为3305，你可以输入\texttt{connect\ gStore\_server\_ip\ gStore\_server\_port} 指定它们。）
%Just type \texttt{bin/gconsole} in the root directory of gStore to use this console, and you will find a \texttt{gstore\textgreater{}} prompt, which indicates that you are in native mode and can type in native commands now. There are another mode of this console, which is called remote mode. Just type \texttt{connect} in the native mode to enter the remote mode, and type \texttt{disconnect} to exit to native mode.(the console connect to a gStore server whose ip is `127.0.0.1' and port is 3305, you can specify them by type \texttt{connect\ gStore\_server\_ip\ gStore\_server\_port})

你可以在本机模式或远程模式中用\texttt{help}或\texttt{?}查看帮助信息，你也可以输入\texttt{help\ command\_name} or \texttt{?\ command\_name}查看某一指令的信息。请注意，本机模式和远程模式的指令有一些区别。例如，\texttt{ls}, \texttt{cd} and \texttt{pwd}这样的系统指令在本机模式中提供，但不在远程模式中提供。也请注意，帮助页中的一些指令还没有完全实现，将来我们可能会改变控制台的一些函数。
%You can use \texttt{help} or \texttt{?} either in native mode or remote mode to see the help information, or you can type \texttt{help\ command\_name} or \texttt{?\ command\_name} to see the information of a given command. Notice that there are some differences between the commands in native mode and commands in remote mode. For example, system commands like \texttt{ls}, \texttt{cd} and \texttt{pwd} are provided in native mode, but not in remote mode. Also take care that not all commands contained in the help page are totally achieved, and we may change some functions of the console in the future.

我们已经完成的工作足以让你便捷地使用gStore，尽情享受吧！
%What we have done is enough to bring you much convenience to use gStore, just enjoy it!

\hyperdef{}{1-gload}{\paragraph{1. gload}\label{1-gload}}

gload用于由RDF三元格式文件生成一个新的数据库。
%gload is used to build a new database from a RDF triple format file.

\texttt{bin/gload\ db\_name\ rdf\_triple\_file\_path}

例如，我们从example文件夹下的LUBM\_10.n3生成数据库。
%For example, we build a database from LUBM\_10.n3 which can be found in example folder.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gload LUBM10.db ./data/LUBM_10.n3
gload...
argc: 3 DB_store:db_LUBM10      RDF_data: ./data/LUBM_10.n3
begin encode RDF from : ./data/LUBM_10.n3 ...
\end{verbatim}

\hyperdef{}{2-gquery}{\paragraph{2. gquery}\label{2-gquery}}

gquery用包含SPARQL的文件查询一个已有的数据库（每个文件包含一条SPARQL查询）。
%gquery is used to query an existing database with files containing SPARQL queries.(each file contains exact one SPARQL query)

输入\texttt{bin/gquery\ db\_name\ query\_file}在名为db\_name的数据库中用query\_file 中的语句执行SPARQL查询。
%Type \texttt{bin/gquery\ db\_name\ query\_file} to execute the SPARQL query retrieved from query\_file in the database named db\_name.

使用\texttt{bin/gquery\ -\/-help}获得关于gquery用法的详细信息。
%Use \texttt{bin/gquery\ -\/-help} for detail information of gquery usage.

输入\texttt{bin/gquery\ db\_name}进入gquery控制台。程序会给出一个命令提示符（“gsql\textgreater{}”），你可以在此处输入命令。使用\texttt{help}查看所有指令的基本信息，\texttt{help\ command\_t}给出特定指令的详细信息。
%To enter the gquery console, type \texttt{bin/gquery\ db\_name}. The program shows a command prompt(``gsql\textgreater{}''), and you can type in a command here. Use \texttt{help} to see basic information of all commands, while \texttt{help\ command\_t} shows details of a specified command.

输入\texttt{quit}离开gquery控制台。
%Type \texttt{quit} to leave the gquery console.

对于\texttt{sparql}指令，输入包含单个SPARQL查询的文件路径。(\emph{支持将结果重新定向到文件。})
%For \texttt{sparql} command, input a file path which contains a single SPARQL query. (\emph{answer redirecting to file is supported})

程序完成查询时，会再次显示命令提示符。
%When the program finish answering the query, it shows the command prompt again.

\emph{gStore2.0目前只支持简单``select'' 查询（不针对谓词）}
%\emph{gStore2.0 only support simple ``select'' queries(not for predicates) now.}

我们还是以LUBM\_10.n3为例。
%We also take LUBM\_10.n3 as an example.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gquery LUBM10.db
gquery...
argc: 2 DB_store:db_LUBM10/
loadTree...
LRUCache initial...
LRUCache initial finish
finish loadCache
finish loadEntityID2FileLineMap
open KVstore
finish load
finish loading
Type `help` for information of all commands
Type `help command_t` for detail of command_t
gsql>sparql ./data/LUBM_q0.sql
... ...
Total time used: 4ms.
final result is :
<http://www.Department0.University0.edu/FullProfessor0>
<http://www.Department1.University0.edu/FullProfessor0>
<http://www.Department2.University0.edu/FullProfessor0>
<http://www.Department3.University0.edu/FullProfessor0>
<http://www.Department4.University0.edu/FullProfessor0>
<http://www.Department5.University0.edu/FullProfessor0>
<http://www.Department6.University0.edu/FullProfessor0>
<http://www.Department7.University0.edu/FullProfessor0>
<http://www.Department8.University0.edu/FullProfessor0>
<http://www.Department9.University0.edu/FullProfessor0>
<http://www.Department10.University0.edu/FullProfessor0>
<http://www.Department11.University0.edu/FullProfessor0>
<http://www.Department12.University0.edu/FullProfessor0>
<http://www.Department13.University0.edu/FullProfessor0>
<http://www.Department14.University0.edu/FullProfessor0>
\end{verbatim}

注意：
%Notice:

\begin{itemize}
\item
  如果没有答案，会输出``{[}empty result{]}''，在所有结果后面会有一个空行。
  %``{[}empty result{]}'' will be printed if no answer, and there is an empty line after all results.
\item
  使用了readline库，你可以用键盘上的方向键查看历史指令、移动或修改整个命令。
  %readline lib is used, so you can use arrow key in your keyboard to see command history, and use and arrow key to move and modify your entire command.
\item
  支持路径补全（不是内嵌命令补全）。
  %path completion is supported for utility. (not built-in command completion)
\end{itemize}

\hyperdef{}{3-gserver}{\paragraph{3. gserver}\label{3-gserver}}

gserver是一个后台程序。会在使用gclient或API连接gStore时运行。它通过套接字与客户端通信。
%gserver is a daemon. It should be launched first when accessing gStore by gclient or API. It communicates with client through socket.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gserver
port=3305
Wait for input...
\end{verbatim}

你也可以为监听分配一个定制端口。
%You can also assign a custom port for listening.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gserver 3307
port=3307
Wait for input...
\end{verbatim}

注意：gserver不支持多线程。如果你同时在多个终端启动gclient，gserver会崩溃。
%Notice: Multiple threads are not supported by gserver. If you start up gclient in more than one terminal in the same time, gserver will go down.

\hyperdef{}{4-gclient}{\paragraph{4. gclient}\label{4-gclient}}

gclient是用于发送命令和接收反馈的客户端。
%gclient is designed as a client to send commands and receive feedbacks.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gclient
ip=127.0.0.1 port=3305
gsql>help
help - print commands message
quit - quit the console normally
import - build a database for a given dataset
load - load an existen database
unload - unload an existen database
sparql - load query from the second argument
show - show the current database's name
gsql>import lubm.db data/LUBM_10.n3
import RDF file to database done.
gsql>load lubm.db
load database done.
gsql>sparql "select ?s ?o where { ?s <rdf:type> ?o . }"
[empty result]

gsql>quit
\end{verbatim}

你也可以分配gserver的ip和端口。
%You can also assign gserver's ip and port.

\begin{verbatim}
[bookug@localhost gStore]$ bin/gclient 172.31.19.15 3307
ip=172.31.19.15 port=3307
gsql>
\end{verbatim}

我们现在可以使用以下命令：
%We can use these following commands now:

\begin{itemize}
\item
  \texttt{help} 显示所有指令的信息
  %\texttt{help} shows the information of all commands
\item
  \texttt{import\ db\_name\ rdf\_triple\_file\_name} 从一个RDF三元组文件生成数据库
  %\texttt{import\ db\_name\ rdf\_triple\_file\_name} build a database from RDF triple file
\item
  \texttt{load\ db\_name} 载入一个已存在的数据库
  %\texttt{load\ db\_name} load an existing database
\item
  \texttt{unload\ db\_name} 卸载一个数据库，但不会从磁盘上删除它，你可以再次载入
  %\texttt{unload\ db\_name} unload database, but will not delete it on disk, you can load it next time
\item
  \texttt{sparql\ "query\_string"} 用一个SPARQL查询字符串（在``''内）查询当前数据库
  %\texttt{sparql\ "query\_string"} query the current database with a SPARQL query string(quoted by ``'')
\item
  \texttt{show} 显示当前数据库的名称
  %\texttt{show} displays the name of the current loaded database
\end{itemize}

注意：
%Notice:

\begin{itemize}
\item
  在gclient控制台最多只能载入一个数据库
  %at most one database can be loaded in the gclient console
\item
  你可以在指令的不同部分之间加上` '或`\textbackslash{}t'，但不要使用`;'之类的字符
  %you can place ` ' or `\textbackslash{}t' between different parts of command, but not use characters like `;'
\item
  在指令前不能有空格或制表符
  %you should not place any space or tab ahead of the start of any command
\end{itemize}

\hyperdef{}{5-test-utilities}{\paragraph{5. 测试工具}\label{5-test-utilities}}
%\hyperdef{}{5-test-utilities}{\paragraph{5. test utilities}\label{5-test-utilities}}

test/文件夹下有一系列测试程序，我们会介绍两个比较有用的：gtest.cpp和full\_test.sh
%A series of test program are placed in the test/ folder, and we will introduce the two useful ones: gtest.cpp and full\_test.sh

\textbf{gtest用多个数据集和查询测试gStore。}
%\textbf{gtest is used to test gStore with multiple datasets and queries.}

要使用gtest，请先输入\texttt{make\ gtest} 编译gtest程序。gtest程序为数据集生产结构日志。请在工作目录下输入\texttt{./gtest\ -\/-help}获取更多信息。
%To use gtest utility, please type \texttt{make\ gtest} to compile the gtest program first. Program gtest is a test tool to generate structural logs for datasets. Please type \texttt{./gtest\ -\/-help} in the working directory for details.

\textbf{如果需要请改变test/gtest.cpp中的路径。}
%\textbf{Please change paths in the test/gtest.cpp if needed.}

你应该如下设置数据集和查询：
%You should place the datasets and queries in this way:

\begin{verbatim}
DIR/WatDiv/database/*.nt

DIR/WatDiv/query/*.sql
\end{verbatim}

请注意，DIR是你要用于gtest的所有数据集的根目录，WatDiv和LUBM一样，是数据集类。在WatDiv内或LUBM等，请将所有的数据集（用.nt 命名）放在database/文件夹下，并将所有查询（和数据集对应，用.sql命名）放在query文件夹下。
%Notice that DIR is the root directory where you place all datasets waiting to be used by gtest. And WatDiv is a class of datasets, as well as LUBM. Inside WatDiv(or LUBM, etc. please place all datasets(named with .nt) in a database/ folder, and place all queries(corresponding to datasets, named with .sql) in a query folder.

之后你可以用指定的参数运行gtest程序，输出会被分类并储存到gStore根目录下的三个日志内：load.log/（数据库加载时间和大小），time.log/（查询时间）和result.log/（所有查询结果，不是整个结束字符串，而是记录选定的两个数据库系统是否匹配的信息。）
%Then you can run the gtest program with specified parameters, and the output will be sorted into three logs in gStore root directory: load.log/(for database loading time and size), time.log/(for query time) and result.log/(for all query results, not the entire output strings, but the information to record the selected two database systems matched or not).

程序产生的所有日志都以TSV格式储存（用`\textbackslash{}t'分隔），你可以直接将它们加载入Calc/Excel/Gnumeric。请注意，时间单位是ms，空间单位是kb。
%All logs produced by this program are in TSV format(separated with `\textbackslash{}t'), you can load them into Calc/Excel/Gnumeric directly. Notice that time unit is ms, and space unit is kb.

\textbf{full\_test.sh用多个数据集和查询比较gStore和其他数据库系统的性能。}
%\textbf{full\_test.sh is used to compare the performance of gStore and other database systems on multiple datasets and queries.}

要使用full\_test.sh，请下载你想要比较的数据库系统，并在这一脚本中准确设置数据库系统和数据集的位置。命名策略和日志策略应该与gtest的要求一致。
%To use full\_test.sh utility, please download the database system which you want to tats and compare, and set the exact position of database systems and datasets in this script. The name strategy should be the same as the requirements of gtest, as well as the logs strategy.

在这一脚本中仅测试比较了gStore和Jena，如果你愿意花时间阅读这一脚本，很容易添加其他数据库系统。如果遇到问题，你可以到\href{run:../pdf/gstore???????.pdf}{测试报告}或\hyperref[chapter09]{【FAQ】}一章寻求帮助。
%Only gStore and Jena are tested and compared in this script, but it is easy to add other database systems, if you would like to spend some time on reading this script. You may go to \href{run:../pdf/gstore???????.pdf}{test report} or \hyperref[chapter09]{Frequently Asked Questions} for help if you encounter a problem.

\clearpage

\part{高级}
%\part{Advanced}

\hyperdef{}{chapter05}{\subsection{第05章：API说明}\label{chapter05}}
%\hyperdef{}{chapter05}{\subsection{Chapter 05: API Explanation}\label{chapter05}}

\textbf{本章节将引导你用我们的API连接gStore。}
%\textbf{This Chapter guides you to use our API for accessing gStore.}

\hyperdef{}{easy-examples}{\subsubsection{简单样例}\label{easy-examples}}
%\hyperdef{}{easy-examples}{\subsubsection{Easy Examples}\label{easy-examples}}

我们目前提供了JAVA和C++的gStore API。请参考\texttt{api/cpp/example}和\texttt{api/java/example}的样例代码。要使用这两个样例，请确保已经生成了可执行程序。如果没有生成，只需要在gStore根目录下输入\texttt{make\ APIexample}来编译代码和API。
%We provide JAVA and C++ API for gStore now. Please refer to example codes in \texttt{api/cpp/example} and \texttt{api/java/example}. To use the two examples to have a try, please ensure that executables have already been generated. Otherwise, just type \texttt{make\ APIexample} in the root directory of gStore to compile the codes, as well as API.

接下来，\textbf{用\texttt{./gserver}指令启动gStore服务器。}如果你知道一个正在运行的可用的gStore服务器，你可以尝试连接它，请注意\textbf{服务器ip、服务器和客户端的端口号必须匹配。}（样例使用默认设置，不需要更改。）之后，你需要在gStore/api/目录下编译样例代码。我们提供了一个程序，只需要在gStore根目录下输入\texttt{make\ APIexample}。 或者你可以自己编译代码，在本例中，请分别打开gStore/api/cpp/example/和gStore/api/java/example/。
%Next, \textbf{start up a gStore server by using \texttt{./gserver} command.} It is ok if you know a running usable gStore server and try to connect to it, but notice that \textbf{the server ip and port of server and client must be matched.}(you don't need to change any thing if using examples, just by default) Then, you need to compile the example codes in the directory gStore/api/. We provide a utility to do this, and you just need to type \texttt{make\ APIexample} in the root directory of gStore. Or you can compile the codes by yourself, in this case please go to gStore/api/cpp/example/ and gStore/api/java/example/, respectively.

最后，打开样例目录并运行相应的可执行程序。对C++而言，用\texttt{./example}指令运行。对Java而言，用\texttt{make\ run}指令或\texttt{java\ -cp\ ../lib/GstoreJavaAPI.jar:.\ JavaAPIExample}运行。两个可执行程序都会连接到指定的gStore服务器并做一些加载或查询操作。请确保你在运行样例的终端看到了查询结果，如果没有，请参阅\hyperref[chapter09]{【FAQ】}一章或向我们报告。（\hyperref[chapter00]{【README】}中描述了报告方法。）
%Finally, go to the example directory and run the corresponding executables. For C++, just use \texttt{./example} command to run it. And for Java, use \texttt{make\ run} command or \texttt{java\ -cp\ ../lib/GstoreJavaAPI.jar:.\ JavaAPIExample} to run it. Both the two executables will connect to a specified gStore server and do some load or query operations. Be sure that you see the query results in the terminal where you run the examples, otherwise please go to \hyperref[chapter09]{Frequently Asked Questions} for help or report it to us.(the report approach is described in \hyperref[chapter00]{README})

我们建议你仔细阅读样例代码和相应的Makefile。这会帮助你理解API，特别是如果你想基于API接口写自己的程序。
%You are advised to read the example code carefully, as well as the corresponding Makefile. This will help you to understand the API, specially if you want to write your own programs based on the API interface.

\hyperdef{}{api-structure}{\subsubsection{API 结构}\label{api-structure}}
%\hyperdef{}{api-structure}{\subsubsection{API structure}\label{api-structure}}

gStore的API在gStore根目录的api/目录下，内容如下：
%The API of gStore is placed in api/ directory in the root directory of gStore, whose contents are listed below:

\begin{itemize}
\item
  gStore/api/

  \begin{itemize}
  \item
    cpp/ （C++ API）
    %cpp/ (the C++ API)

    \begin{itemize}
    \item
      src/ （C++ API的源代码，用于生成lib/libgstoreconnector.a）
      %src/ (source code of C++ API, used to build the lib/libgstoreconnector.a)

      \begin{itemize}
      \item
        GstoreConnector.cpp （与gStore服务器交互的接口）
        %GstoreConnector.cpp (interfaces to interact with gStore server)
      \item
        GstoreConnector.h
      \item
        Makefile （编译并生成lib）
        %Makefile (compile and build lib)
      \end{itemize}
    \item
      lib/ （静态库所在）
      %lib/ (where the static lib lies in)

      \begin{itemize}
      \item
        .gitignore
      \item
        libgstoreconnector.a (只在编译后存在，使用C++ API时需要连接这个库)
        %libgstoreconnector.a (only exist after compiled, you need to link this lib when you use the C++ API)
      \end{itemize}
    \item
      example/ （样例程序，展示使用C++ API的基本思路）
      %example/ (small example program to show the basic idea of using the C++ API)

      \begin{itemize}
      \item
        CppAPIExample.cpp
      \item
        Makefile
      \end{itemize}
    \end{itemize}
  \item
    java/ （Java API）
    %java/ (the Java API)

    \begin{itemize}
    \item
      src/ （Java API的源代码，用于生成lib/GstoreJavaAPI.jar）
      %src/ (source code of Java API, used to build the lib/GstoreJavaAPI.jar)

      \begin{itemize}
      \item
        jgsc/GstoreConnector.java （使用Java API时需要导入的包）
        %jgsc/GstoreConnector.java (the package which you need to import when you use the Java API)
      \item
        Makefile （编译并生成库）
        %Makefile (compile and build lib)
      \end{itemize}
    \item
      lib/

      \begin{itemize}
      \item
        .gitignore
      \item
        GstoreJavaAPI.jar （只在编译后存在，你需要在类目录中包括这一JAR）
        %GstoreJavaAPI.jar (only exist after compiled, you need to include this JAR in your class path)
      \end{itemize}
    \item
      example/ （样例程序，展示使用Java API的基本思路）
      %example/ (small example program to show the basic idea of using the Java API)

      \begin{itemize}
      \item
        JavaAPIExample.cpp
      \item
        Makefile
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

\hyperdef{}{c-api}{\subsubsection{C++ API}\label{c-api}}

\hyperdef{}{interface}{\paragraph{接口}\label{interface}}
%\hyperdef{}{interface}{\paragraph{Interface}\label{interface}}

要使用C++ API，请在你的cpp代码中加入\texttt{\#include\ "GstoreConnector.h"}。GstoreConnector.h中的函数可以如下调用：
%To use the C++ API, please place the phrase \texttt{\#include\ "GstoreConnector.h"} in your cpp code. Functions in GstoreConnector.h should be called like below:

\begin{verbatim}
// initialize the Gstore server's IP address and port.
GstoreConnector gc("127.0.0.1", 3305);
// build a new database by a RDF file.
// note that the relative path is related to gserver.
gc.build("LUBM10.db", "example/LUBM_10.n3");
// then you can execute SPARQL query on this database.
std::string sparql = "select ?x where \
{\
?x    <rdf:type>    <ub:UndergraduateStudent>. \
?y    <ub:name> <Course1>. \
?x    <ub:takesCourse>  ?y. \
?z    <ub:teacherOf>    ?y. \
?z    <ub:name> <FullProfessor1>. \
?z    <ub:worksFor>    ?w. \
?w    <ub:name>    <Department0>. \
}";
std::string answer = gc.query(sparql);
// unload this database.gc.unload("LUBM10.db");
// also, you can load some exist database directly and then query.
gc.load("LUBM10.db");
// query a SPARQL in current database
answer = gc.query(sparql);
\end{verbatim}

原始的函数声明如下：
%The original declaration of these functions are as below:

\begin{verbatim}
GstoreConnector();
GstoreConnector(string _ip, unsigned short _port);
GstoreConnector(unsigned short _port);
bool load(string _db_name);
bool unload(string _db_name);
bool build(string _db_name, string _rdf_file_path);
string query(string _sparql);
\end{verbatim}

注意：
%Notice:

\begin{enumerate}
\item
  在使用GstoreConnector()时，ip和端口的默认值分别是127.0.0.1和3305。
  %When using GstoreConnector(), the default value for ip and port is 127.0.0.1 and 3305, respectively.
\item
  在使用build()时，rdf\_file\_path（第二个参数）应该和gserver的位置相关。
  %When using build(), the rdf\_file\_path(the second parameter) should be related to the position where gserver lies in.
\item
  请记得卸载你导入的数据库，否则可能会出错。（错误可能不被报告！）
  %Please remember to unload the database you have loaded, otherwise things may go wrong.(the errors may not be reported!)
\end{enumerate}

\hyperdef{}{compile}{\paragraph{编译}\label{compile}}
%\hyperdef{}{compile}{\paragraph{Compile}\label{compile}}

我们建议你在gStore/api/cpp/example/Makefile中查看如何用C++ API编译你的代码。通常来说，你必须要将代码编译为包含了C++ API 头的目标文件，并将目标文件连接到C++ API中的静态库。
%You are advised to see gStore/api/cpp/example/Makefile for instructions on how to compile your code with the C++ API. Generally, what you must do is compile your own code to object with header in the C++ API, and link the object with static lib in the C++ API.

我们假设你的源代码在test.cpp中，位置为\$\{GSTORE\}/gStore/。（如果名字是devGstores 而不是gStore，那么路径为\$\{GSTORE\}/devGstore/）
%Let us assume that your source code is placed in test.cpp, whose position is \$\{GSTORE\}/gStore/.(if using devGstore as name instead of gStore, then the path is \$\{GSTORE\}/devGstore/ directory first:

\begin{quote}
用\texttt{g++\ -c\ -I\$\{GSTORE\}/gStore/api/cpp/src/\ test.cpp\ -o\ test.o}将你的test.cpp编译成test.o，相关的API头在api/cpp/src/中。
%Use \texttt{g++\ -c\ -I\$\{GSTORE\}/gStore/api/cpp/src/\ test.cpp\ -o\ test.o} to compile your test.cpp into test.o, relative API header is placed in api/cpp/src/.

用\texttt{g++\ -o\ test\ test.o\ -L\$\{GSTORE\}/gStore/api/cpp/lib/\ -lgstoreconnector}将test.o连接到api/cpp/lib/中的libgstoreconnector.a(静态库)。
%Use \texttt{g++\ -o\ test\ test.o\ -L\$\{GSTORE\}/gStore/api/cpp/lib/\ -lgstoreconnector} to link your test.o with the libgstoreconnector.a(a static lib) in api/cpp/lib/.
\end{quote}

接下来，你可以输入\texttt{./test}执行使用了C++ API的程序。我们还建议你将相关的编译命令和其他你需要的命令放在Makefile中。
%Then you can type \texttt{./test} to execute your own program, which uses our C++ API. It is also advised for you to place relative compile commands in a Makefile, as well as other commands if you like.

\hyperdef{}{java-api}{\subsubsection{Java API}\label{java-api}}

\hyperdef{}{interface-1}{\paragraph{接口}\label{interface-1}}
%\hyperdef{}{interface-1}{\paragraph{Interface}\label{interface-1}}

要使用Java API，请在java代码中加入\texttt{import\ jgsc.GstoreConnector;}。GstoreConnector.java 中的函数应该如下调用：
%To use the Java API, please place the phrase \texttt{import\ jgsc.GstoreConnector;} in your java code. Functions in GstoreConnector.java should be called like below:

\begin{verbatim}
// initialize the Gstore server's IP address and port.
GstoreConnector gc = new GstoreConnector("127.0.0.1", 3305);
// build a new database by a RDF file.
// note that the relative path is related to gserver.
gc.build("LUBM10.db", "example/LUBM_10.n3");
// then you can execute SPARQL query on this database.
String sparql = "select ?x where " + "{" +
"?x    <rdf:type>    <ub:UndergraduateStudent>. " +
"?y    <ub:name> <Course1>. " +
"?x    <ub:takesCourse>  ?y. " +
"?z    <ub:teacherOf>    ?y. " +
"?z    <ub:name> <FullProfessor1>. " +
"?z    <ub:worksFor>    ?w. " +
"?w    <ub:name>    <Department0>. " +
"}";
String answer = gc.query(sparql);
//unload this database.
gc.unload("LUBM10.db");
//also, you can load some exist database directly and then query.
gc.load("LUBM10.db");// query a SPARQL in current database
answer = gc.query(sparql);
\end{verbatim}

这些函数的原始声明如下：
%The original declaration of these functions are as below:

\begin{verbatim}
GstoreConnector();
GstoreConnector(string _ip, unsigned short _port);
GstoreConnector(unsigned short _port);
bool load(string _db_name);
bool unload(string _db_name);
bool build(string _db_name, string _rdf_file_path);
string query(string _sparql);
\end{verbatim}

注意：
%Notice:

\begin{enumerate}
\item
  在使用GstoreConnector()时，ip和端口的默认值分别是127.0.0.1和3305。
  %When using GstoreConnector(), the default value for ip and port is 127.0.0.1 and 3305, respectively.
\item
  在使用build()时，rdf\_file\_path（第二个参数）应该和gserver的位置相关。
  %When using build(), the rdf\_file\_path(the second parameter) should be related to the position where gserver lies in.
\item
  请记得卸载你导入的数据库，否则可能会出错。（错误可能不被报告！）
  %Please remember to unload the database you have loaded, otherwise things may go wrong.(the errors may not be reported!)
\end{enumerate}

\hyperdef{}{compile-1}{\paragraph{编译}\label{compile-1}}
\hyperdef{}{compile-1}{\paragraph{Compile}\label{compile-1}}

我们建议你在gStore/api/java/example/Makefile中查看如何用Java API编译你的代码。通常来说，你必须要将代码编译为包含了Java API 中jar文件的目标文件。
%You are advised to see gStore/api/java/example/Makefile for instructions on how to compile your code with the Java API. Generally, what you must do is compile your own code to object with jar file in the Java API.

我们假设你的源代码在test.java中，位置为\$\{GSTORE\}/gStore/。（如果名字是devGstores 而不是gStore，那么路径为\$\{GSTORE\}/devGstore/）
%Let us assume that your source code is placed in test.java, whose position is \$\{GSTORE\}/gStore/.(if using devGstore as name instead of gStore, then the path is \$\{GSTORE\}/devGstore/ directory first:

\begin{quote}
用\texttt{javac\ -cp\ \$\{GSTORE\}/gStore/api/java/lib/GstoreJavaAPI.jar\ test.java}将test.java编译为使用了api/java/lib/ 中GstoreJavaAPI.jar（Java 中使用的jar包）的test.class
%Use \texttt{javac\ -cp\ \$\{GSTORE\}/gStore/api/java/lib/GstoreJavaAPI.jar\ test.java} to compile your test.java into test.class with the GstoreJavaAPI.jar(a jar package used in Java) in api/java/lib/.
\end{quote}

接下来，你可以输入\texttt{java\ -cp\ \$\{GSTORE\}/gStore/api/java/lib/GstoreJavaAPI.jar:.\ test}执行使用了Java API的程序（注意，命令中的``:.''不能省略）。我们还建议你将相关的编译命令和其他你需要的命令放在Makefile中。
%Then you can type \texttt{java\ -cp\ \$\{GSTORE\}/gStore/api/java/lib/GstoreJavaAPI.jar:.\ test} to execute your own program(notice that the ``:.'' in command cannot be neglected), which uses our Java API. It is also advised for you to place relative compile commands in a Makefile, as well as other commands if you like.

\clearpage

\hyperdef{}{chapter06}{\subsection{第06章：项目结构}\label{chapter06}}
%\hyperdef{}{chapter06}{\subsection{Chapter 06: Project Structure}\label{chapter06}}

\textbf(本章介绍了gStore系统项目的整体结构。)
%\textbf{This chapter introduce the whole structure of the gStore system project.}

\hyperdef{}{the-core-source-codes}{\paragraph{核心源代码如下列出：}\label{the-core-source-codes}}
\hyperdef{}{the-core-source-codes}{\paragraph{The core source codes are listed below:}\label{the-core-source-codes}}

\begin{itemize}
\item
  Database/ （调用其他核心部分，处理接口部分的请求）
  %Database/ (calling other core parts to deal with requests from interface part)

  \begin{itemize}
  \item
    Database.cpp （实现函数）
    %Database.cpp (achieve functions)
  \item
    Database.h （类、成员和函数定义）
    %Database.h (class, members and functions definitions)
  \item
    Join.cpp （连接候选结点得到结果）
    %Join.cpp (join the node candidates to get results)
  \item
    Join.h （类、成员和函数定义）
    %Join.h (class, members,, and functions definitions)
  \end{itemize}
\item
  KVstore/ （键-值存储，在内存和磁盘间交换）
  %KVstore/ (a key-value store to swap between memory and disk)

  \begin{itemize}
  \item
    KVstore.cpp （和上层交互）
    %KVstore.cpp (interact with upper layers)
  \item
    KVstore.h
  \item
    heap/ （结点堆，内容在内存中）
    %heap/ (a heap of nodes whose content are in memory)

    \begin{itemize}
    \item
      Heap.cpp
    \item
      Heap.h
    \end{itemize}
  \item
    node/ （B+-树中的各种结点）
    %node/ (all kinds of nodes in B+-tree)

    \begin{itemize}
    \item
      Node.cpp （IntlNode和LeafNode 的基类）
      %Node.cpp (the base class of IntlNode and LeafNode)
    \item
      Node.h
    \item
      IntlNode.cpp （B+-树的内部结点）
      %IntlNode.cpp (internal nodes in B+-tree)
    \item
      IntlNode.h
    \item
      LeafNode.cpp （B+-树的叶子结点）
      %LeafNode.cpp (leaf nodes in B+-tree)
    \item
      LeafNode.h
    \end{itemize}
  \item
    storage/ （在内存和磁盘间交换内容）
    %storage/ (swap contents between memory and disk)

    \begin{itemize}
    \item
      file.h
    \item
      Storage.cpp
    \item
      Storage.h
    \end{itemize}
  \item
    tree/ （实现所有的树操作和接口）
    %tree/ (implement all tree operations and interfaces)

    \begin{itemize}
    \item
      Tree.cpp
    \item
      Tree.h
    \end{itemize}
  \end{itemize}
\item
  Query/ （回答SPARQL查询时需要）
  %Query/ (needed to answer SPARQL query)

  \begin{itemize}
  \item
    BasicQuery.cpp （不含聚集操作的基本查询类型）
    %BasicQuery.cpp (basic type of queries without aggregate operations)
  \item
    BasicQuery.h
  \item
    IDList.cpp （查询结点/变量的候选列表）
    %IDList.cpp (candidate list of a node/variable in query)
  \item
    IDList.h
  \item
    ResultSet.cpp （储存对应查询的结果集）
    %ResultSet.cpp (keep the result set corresponding to a query)
  \item
    ResultSet.h
  \item
    SPARQLquery.cpp （处理整个SPARQL查询）
    %SPARQLquery.cpp (deal with a entire SPARQL query)
  \item
    SPARQLquery.h
  \item
    Varset.cpp
  \item
    Varset.h
  \item
    QueryTree.cpp
  \item
    QueryTree.h
  \item
    GeneralEvaluation.cpp
  \item
    GeneralEvaluation.h
  \item
    RegexExpression.h
  \end{itemize}
\item
  Signature/ （为结点和边分配签名，但不为文字分配）
  %Signature/ (assign signatures for nodes and edges, but not for literals)

  \begin{itemize}
  \item
    SigEntry.cpp
  \item
    SigEntry.h
  \item
    Signature.cpp
  \item
    Signature.h
  \end{itemize}
\item
  VSTree/ （高效修剪的树索引）
  %VSTree/ (an tree index to prune more efficiently)

  \begin{itemize}
  \item
    EntryBuffer.cpp
  \item
    EntryBuffer.h
  \item
    LRUCache.cpp
  \item
    LRUCache.h
  \item
    VNode.cpp
  \item
    VNode.h
  \item
    VSTree.cpp
  \item
    VSTree.h
  \end{itemize}
\end{itemize}

\hyperdef{}{the-parser-part}{\paragraph{解析部分如下列出：}\label{the-parser-part}}
%\hyperdef{}{the-parser-part}{\paragraph{The parser part is listed below:}\label{the-parser-part}}

\begin{itemize}
\item
  Parser/

  \begin{itemize}
  \item
    DBParser.cpp
  \item
    DBParser.h
  \item
    RDFParser.cpp
  \item
    RDFParser.h
  \item
    SparqlParser.c （自动生成，手动细微修改，压缩）
    %SparqlParser.c (auto-generated, subtle modified manually, compressed)
  \item
    SparqlParser.h （自动生成，手动细微修改，压缩）
    %SparqlParser.h (auto-generated, subtle modified manually, compressed)
  \item
    SparqlLexer.c （自动生成，手动细微修改，压缩）
    SparqlLexer.c (auto-generated, subtle modified manually, compressed)
  \item
    SparqlLexer.h （自动生成，手动细微修改，压缩）
    %SparqlLexer.h (auto-generated, subtle modified manually, compressed)
  \item
    TurtleParser.cpp
  \item
    TurtleParser.h
  \item
    Type.h
  \item
    QueryParser.cpp
  \item
    QueryParser.h
  \end{itemize}
\end{itemize}

\hyperdef{}{the-utilities}{\paragraph{程序如下列出：}\label{the-utilities}}
%\hyperdef{}{the-utilities}{\paragraph{The utilities are listed below:}\label{the-utilities}}

\begin{itemize}
\item
  Util/

  \begin{itemize}
  \item
    Util.cpp （头，宏，定义类型，函数\ldots{}）
    %Util.cpp (headers, macros, typedefs, functions\ldots{})
  \item
    Util.h
  \item
    Bstr.cpp （展现任意长的字符串）
    %Bstr.cpp (represent strings of arbitrary length)
  \item
    Bstr.h （类、成员和函数定义）
    %Bstr.h (class, members and functions definitions)
  \item
    Stream.cpp （储存并使用临时结果，可能非常大）
    %Stream.cpp (store and use temp results, which may be very large)
  \item
    Stream.h
  \item
    Triple.cpp （处理三元组，一个三元组可以分为主体（实体）、谓词（实体）和客体（实体或文字））
    %Triple.cpp (deal with triples, a triple can be divided as subject(entity), predicate(entity), object(entity or literal))
  \item
    Triple.h
  \item
    BloomFilter.cpp
  \item
    BloomFilter.h
  \end{itemize}
\end{itemize}

\hyperdef{}{the-interface-part}{\paragraph{接口部分如下列出：}\label{the-interface-part}}
%\hyperdef{}{the-interface-part}{\paragraph{The interface part is listed below:}\label{the-interface-part}}

\begin{itemize}
\item
  Server/ （使用gStore的客户端和服务器模式）
  %Server/ (client and server mode to use gStore)

  \begin{itemize}
  \item
    Client.cpp
  \item
    Client.h
  \item
    Operation.cpp
  \item
    Operation.h
  \item
    Server.cpp
  \item
    Server.h
  \item
    Socket.cpp
  \item
    Socket.h
  \end{itemize}
\item
  Main/ （操作gStore的一系列应用/主程序）
  %Main/ (a series of applications/main-program to operate on gStore)

  \begin{itemize}
  \item
    gload.cpp （导入一个RDF数据集）
    %gload.cpp (import a RDF dataset)
  \item
    gquery.cpp （查询一个数据库）
    %gquery.cpp (query a database)
  \item
    gserver.cpp （启动gStore服务器）
    %gserver.cpp (start up the gStore server)
  \item
    gclient.cpp （连接到gStore服务器并交互）
    %gclient.cpp (connect to a gStore server and interact)
  \end{itemize}
\end{itemize}

\hyperdef{}{more-details}{\paragraph{更多细节}\label{more-details}}
%\hyperdef{}{more-details}{\paragraph{More details}\label{more-details}}

获得对gStore代码的深层理解，参阅\href{run:../pdf/code_overview.pdf}{代码细节}。参阅\href{run:../pdf/Gstore2.0_useCaseDoc.pdf}{用例}理解用例的设计，参阅\href{run:../pdf/OOA_class.pdf}{OOA}和\href{run:../pdf/OOD_class.pdf}{OOD}分别查看OOA设计和OOD设计。
%To acquire a deep understanding of gStore codes, please go to \href{run:../pdf/code_overview.pdf}{Code Detail}. See \href{run:../pdf/Gstore2.0_useCaseDoc.pdf}{use case} to understand the design of use cases, and see \href{run:../pdf/OOA_class.pdf}{OOA} and \href{run:../pdf/OOD_class.pdf}{OOD} for OOA design and OOD design, respectively.

如果你想了解运行gStore的流程，阅读下列内容：
%If you want to know the sequence of a running gStore, please view the list below:

\begin{itemize}
\item
  \href{run:../jpg/A01-connectServer.jpg}{连接到服务器}
  %\href{run:../jpg/A01-connectServer.jpg}{connect to server}
\item
  \href{run:../jpg/A02-disconnectServer.jpg}{与服务器断开连接}
  %\href{run:../jpg/A02-disconnectServer.jpg}{disconnect server}
\item
  \href{run:../jpg/A03-loadDatabase.jpg}{加载数据库}
  %\href{run:../jpg/A03-loadDatabase.jpg}{load database}
\item
  \href{run:../jpg/A04-unloadDatabase.jpg}{卸载数据库}
  %\href{run:../jpg/A04-unloadDatabase.jpg}{unload database}
\item
  \href{run:../jpg/A05-buildDatabase.jpg}{创建数据库}
  %\href{run:../jpg/A05-buildDatabase.jpg}{create database}
\item
  \href{run:../jpg/A06-deleteDatabase.jpg}{删除数据库}
  %\href{run:../jpg/A06-deleteDatabase.jpg}{delete database}
\item
  \href{run:../jpg/A07-connectDatabase.jpg}{连接到数据库}
  %\href{run:../jpg/A07-connectDatabase.jpg}{connect to database}
\item
  \href{run:../jpg/A08-disconnectDatabase.jpg}{从数据库断开连接}
  %\href{run:../jpg/A08-disconnectDatabase.jpg}{disconnect database}
\item
  \href{run:../jpg/A09-showDatabase.jpg}{展示数据库}
  %\href{run:../jpg/A09-showDatabase.jpg}{show databases}
\item
  \href{run:../jpg/A10-querySPARQL.jpg}{SPARQL 查询}
  %\href{run:../jpg/A10-querySPARQL.jpg}{SPARQL query}
\item
  \href{run:../jpg/A11-loadRDF.jpg}{导入RDF数据集}
  %\href{run:../jpg/A11-loadRDF.jpg}{import RDF dataset}
\item
  \href{run:../jpg/A12-insertRDF.jpg}{插入一个三元组}
  %\href{run:../jpg/A12-insertRDF.jpg}{insert a triple}
\item
  \href{run:../jpg/A13-deleteRDF.jpg}{删除一个三元组}
  %\href{run:../jpg/A13-deleteRDF.jpg}{delete a triple}
\item
  \href{run:../jpg/B01-createAccount.jpg}{创建账号}
  %\href{run:../jpg/B01-createAccount.jpg}{create account}
\item
  \href{run:../jpg/B02-deleteAccount.jpg}{删除账号}
  %\href{run:../jpg/B02-deleteAccount.jpg}{delete account}
\item
  \href{run:../jpg/B03-changeAccount.jpg}{修改账号权限}
  %\href{run:../jpg/B03-changeAccount.jpg}{modify account authority}
\item
  \href{run:../jpg/B04-removeDatabase.jpg}{强制卸载数据库}
  %\href{run:../jpg/B04-removeDatabase.jpg}{compulsively unload database}
\item
  \href{run:../jpg/B05-showAccount.jpg}{查看账号权限}
  %\href{run:../jpg/B05-showAccount.jpg}{see account authority}
\end{itemize}

如果你在源代码中看到和原始设计的不同的东西，这并不奇怪。一些设计出的函数可能目前还没有实现。
%It is really not strange to see something different with the original design in the source code. And some designed functions may have not be achieved so far.

\hyperdef{}{others}{\paragraph{其他}\label{others}}
%\hyperdef{}{others}{\paragraph{Others}\label{others}}

gStore中的api/文件夹用于存储API程序、库和样例，请参在\hyperref[chapter05]{【API】} 一章中获取更多信息。test/文件夹用于存储一系列测试程序，例如gtest，full\_test等等。和test/有关的章节是\hyperref[chapter04]{【如何使用】}和\hyperref[chapter13]{【测试结果】}。本项目需要ANTLR库解析SPARQL查询，其代码在tools/ 中（也在这里实现），编译的libantlr.a在lib/ 目录下。
%The api/ folder in gStore is used to store API program, libs and examples, please go to \hyperref[chapter05]{API} for details. And test/ is used to store a series test programs or utilities, such as gtest, full\_test and so on. Chapters related with test/ are \hyperref[chapter04]{How To Use} and \hyperref[chapter13]{Test Result}. This project need an ANTLR lib to parse the SPARQL query, whose code is placed in tools/(also archived here) and the compiled libantlr.a is placed in lib/ directory.

我们在data/目录下放置了一些数据集和查询作为样例，你可以尝试它们，看看gStore怎样工作。相关说明在\hyperref[chapter04]{【如何使用】}一章中。docs/目录包含gStore的各类文档，包括一系列markdown文件，还有pdf/和jpg/ 两个文件夹。pdf文件储存在pdf/文件夹下，jpg 文件在jpg/文件夹下。
%We place some datasets and queries in data/ directory as examples, and you can try them to see how gStore works. Related instructions are in \hyperref[chapter04]{How To Use}. The docs/ directory contains all kinds of documents of gStore, including a series of markdown files and two folders, pdf/ and jpg/. Files whose type is pdf are placed in pdf/ folder, while files with jpg type are placed in jpg/ folder.

我们建议你从gStore根目录下的\hyperref[chapter00]{【README】}开始，然后只在需要的时候浏览其他章节。如果你真的对gStore 感兴趣，最后，你会在链接中看到所有文件。
%You are advised to start from the \hyperref[chapter00]{README} in the gStore root directory, and visit other chapters only when needed. At last, you will see all documents from link to link if you are really interested in gStore.

\clearpage

\hyperdef{}{chapter07}{\subsection{第07章：出版物}\label{chapter07}}
%\hyperdef{}{chapter07}{\subsection{Chapter 07: Publications}\label{chapter07}}

\hyperdef{}{publications-related-with-gstore-are-listed-here}{\paragraph{和gStore相关的出版物在此列出：}\label{publications-related-with-gstore-are-listed-here}}
%\hyperdef{}{publications-related-with-gstore-are-listed-here}{\paragraph{Publications related with gStore are listed here:}\label{publications-related-with-gstore-are-listed-here}}

\begin{itemize}
\item
  Lei Zou, M. Tamer $\ddot{O}$zsu,Lei Chen, Xuchuan Shen, Ruizhe Huang, Dongyan Zhao, \href{http://www.icst.pku.edu.cn/intro/leizou/projects/papers/gStoreVLDBJ.pdf}{gStore: A Graph-based SPARQL Query Engine}, VLDB Journal , 23(4): 565-590, 2014.
\item
  Lei Zou, Jinghui Mo, Lei Chen,M. Tamer $\ddot{O}$zsu, Dongyan Zhao, \href{http://www.icst.pku.edu.cn/intro/leizou/projects/papers/p482-zou.pdf}{gStore: Answering SPARQL Queries Via Subgraph Matching}, Proc. VLDB 4(8): 482-493, 2011.
\item
  Xuchuan Shen, Lei Zou, M. Tamer $\ddot{O}$zsu, Lei Chen, Youhuan Li, Shuo Han, Dongyan Zhao, \href{http://www.icst.pku.edu.cn/intro/leizou/projects/papers/demo.pdf}{A Graph-based RDF Triple Store}, ICDE 2015: 1508-1511.
\item
  Peng Peng, Lei Zou, M. Tamer $\ddot{O}$zsu, Lei Chen, Dongyan Zhao: \href{http://arxiv.org/pdf/1411.6763v4.pdf}{Processing SPARQL queries over distributed RDF graphs}. VLDB Journal 25(2): 243-268 (2016).
\item
  Dong Wang, Lei Zou, Yansong Feng, Xuchuan Shen, Jilei Tian, and Dongyan Zhao,   \href{http://www.icst.pku.edu.cn/intro/leizou/projects/papers/Store.pdf}{S-store: An Engine for Large RDF Graph Integrating Spatial Information}, in Proc. 18th International Conference on Database Systems for Advanced   Applications (DASFAA), pages 31-47, 2013.
\item
  Dong Wang, Lei Zou and Dongyan Zhao,   \href{http://www.icst.pku.edu.cn/intro/leizou/projects/papers/edbtdemo2014.pdf}{gst-Store: An Engine for Large RDF Graph Integrating Spatiotemporal Information}, in Proc. 17th International Conference on Extending Database
  Technology (EDBT), pages 652-655, 2014 (demo).
\item
  Lei Zou, Yueguo Chen, \href{http://www.icst.pku.edu.cn/intro/leizou/documentation/pdf/2012CCCF.pdf}{A Survey of Large-Scale RDF Data Management}, Comunications of CCCF Vol.8(11): 32-43, 2012 (Invited Paper, in Chinese).
\end{itemize}

\clearpage

\hyperdef{}{chapter08}{\subsection{第08章：限制}\label{chapter08}}
%\hyperdef{}{chapter08}{\subsection{Chapter 08: Limitations}\label{chapter08}}

\begin{enumerate}
\item
  不支持包含无限谓词的查询。
  %Queries related with unbounded predicates are not supported.
\item
  这一版本只支持SPARQL select查询。
  %This version only supports SPARQL select query.
\item
  只支持N3格式的RDF文件。下一版本会支持更多文件格式。
  %Only support RDF file in N3 file format. More file formats will be supported in the next version.
\end{enumerate}

\clearpage

\hyperdef{}{chapter09}{\subsection{第09章：FAQ}\label{chapter09}}
%\hyperdef{}{chapter09}{\subsection{Chapter 09: Frequently Asked Questions}\label{chapter09}}

\hyperdef{}{when-i-use-the-newer-gstore-system-to-query-the-original-database-why-error}{\paragraph{使用更新版本的gStore系统查询原始数据库时，为什么会出错？}\label{when-i-use-the-newer-gstore-system-to-query-the-original-database-why-error}}
%\hyperdef{}{when-i-use-the-newer-gstore-system-to-query-the-original-database-why-error}{\paragraph{When I use the newer gStore system to query the original database, why error?}\label{when-i-use-the-newer-gstore-system-to-query-the-original-database-why-error}}
\quad\\
gStore生产的数据库包含一些索引，其结构可能在新的gStore版本中发生了改变。所以，以防万一，请重新生成数据集。
%The database produced by gStore contains several indexes, whose structures may have been chnaged in the new gStore version. So, please rebuild your dataset just in case.

\hyperdef{}{why-error-when-i-try-to-write-programs-based-on-gstore-just-like-the-maingconsolecpp}{\paragraph{我试着写类似Main/gconsole.cpp的基于gStore的程序时，为什么会出错？}\label{why-error-when-i-try-to-write-programs-based-on-gstore-just-like-the-maingconsolecpp}}
%\hyperdef{}{why-error-when-i-try-to-write-programs-based-on-gstore-just-like-the-maingconsolecpp}{\paragraph{Why error when I try to write programs based on gStore, just like the Main/gconsole.cpp?}\label{why-error-when-i-try-to-write-programs-based-on-gstore-just-like-the-maingconsolecpp}}
\quad\\
你需要在你的主程序开头加入这些语句，否则gStore无法正确运行：\\ //NOTICE:this is needed to set several debug files\\ Util util;
%You need to add these phrases at the beginning of your main program, otherwise gStore will not run correctly:\\ //NOTICE:this is needed to set several debug files\\ Util util;

\hyperdef{}{why-does-gstore-report-garbage-collection-failed-error-when-i-use-teh-java-api}{\paragraph{\texorpdfstring{我使用Java API时，为什么gStore报告``garbage collection failed''错误？}{Why does gStore report garbage collection failed error when I use teh Java API?}}\label{why-does-gstore-report-garbage-collection-failed-error-when-i-use-teh-java-api}}
%\hyperdef{}{why-does-gstore-report-garbage-collection-failed-error-when-i-use-teh-java-api}{\paragraph{\texorpdfstring{Why does gStore report ``garbage collection failed'' error when I use the Java API?}{Why does gStore report garbage collection failed error when I use teh Java API?}}\label{why-does-gstore-report-garbage-collection-failed-error-when-i-use-teh-java-api}}
\quad\\
你需要调整jvm参数，参见\href{http://www.cnblogs.com/edwardlauxh/archive/2010/04/25/1918603.html}{url1} 和\href{http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html}{url2} 获取更多细节。
%You need to adjust the parameters of jvm, see \href{http://www.cnblogs.com/edwardlauxh/archive/2010/04/25/1918603.html}{url1} and \href{http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html}{url2} for details.

\hyperdef{}{when-i-compile-the-code-in-archlinux-why-the-error-that-no-ltermcap-is-reported}{\paragraph{\texorpdfstring{我在ArchLinux中编译代码时，为什么报告``no -ltermcap''错误？}{When I compile the code in ArchLinux, why the error that no -ltermcap is reported?}}\label{when-i-compile-the-code-in-archlinux-why-the-error-that-no-ltermcap-is-reported}}
%\hyperdef{}{when-i-compile-the-code-in-archlinux-why-the-error-that-no-ltermcap-is-reported}{\paragraph{\texorpdfstring{When I compile the code in ArchLinux, why the error that ``no -ltermcap'' is reported?}{When I compile the code in ArchLinux, why the error that no -ltermcap is reported?}}\label{when-i-compile-the-code-in-archlinux-why-the-error-that-no-ltermcap-is-reported}}
\quad\\
在ArchLinux下，你只需要用\texttt{-lreadline}连接readline库。如果你要使用ArchLinux，请移除gStore根目录下makefile中的\texttt{-ltermcap}。
%In ArchLinux, you only need to use \texttt{-lreadline} to link the readline library. Please remove the \texttt{-ltermcap} in the makefile which is located in the root of the gStore project if you would like to use ArchLinux.

\hyperdef{}{why-does-gstore-report-errors-that-the-format-of-some-rdf-datasets-are-not-supported}{\paragraph{为什么gStore 报告错误称不支持一些RDF数据集的格式？}\label{why-does-gstore-report-errors-that-the-format-of-some-rdf-datasets-are-not-supported}}
%\hyperdef{}{why-does-gstore-report-errors-that-the-format-of-some-rdf-datasets-are-not-supported}{\paragraph{Why does gStore report errors that the format of some RDF datasets are not supported?}\label{why-does-gstore-report-errors-that-the-format-of-some-rdf-datasets-are-not-supported}}
\quad\\
gStore现在不支持所有的RDF格式，请参阅\href{run:../../test/format_question.txt}{格式}获取细节。很容易将RDF数据格式转换为用于gStore的N3文件格式。
%gStore does not support all RDF formats currently, please see \href{run:../../test/format_question.txt}{formats} for details. However, it is quite easy for you to convey your RDF data format to the N3 file format that is used in gStore.

\hyperdef{}{when-i-read-on-github-why-are-some-documents-unable-to-be-opened}{\paragraph{我在GitHub上阅读的时候，为什么有一些文件打不开？}\label{when-i-read-on-github-why-are-some-documents-unable-to-be-opened}}
%\hyperdef{}{when-i-read-on-github-why-are-some-documents-unable-to-be-opened}{\paragraph{When I read on GitHub, why are some documents unable to be opened?}\label{when-i-read-on-github-why-are-some-documents-unable-to-be-opened}}
\quad\\
代码、markdown、其他文本文件和图片可以直接在GitHub上阅读。如果你使用的是轻量级浏览器，例如midori，对于pdf文件请将下载后在电脑或其他设备上阅读。
%Codes, markdowns or other text files, and pictures can be read directly on GitHub. However, if you are using some light weight browsers like midori, for files in pdf type, please download them and read on your computer or other devices.

\hyperdef{}{why-sometimes-strange-characters-appear-when-i-use-gstore}{\paragraph{为什么使用gStore时有时候会出现奇怪的字符？}\label{why-sometimes-strange-characters-appear-when-i-use-gstore}}
%\hyperdef{}{why-sometimes-strange-characters-appear-when-i-use-gstore}{\paragraph{Why sometimes strange characters appear when I use gStore?}\label{why-sometimes-strange-characters-appear-when-i-use-gstore}}
\quad\\
一些文件的名称是中文，你不需要担心这个问题。
%There are some documents's names are in Chinese, and you don't need to worry about it.

\hyperdef{}{in-centos7-if-the-watdivdba-generated-database-after-gload-is-copied-or-compresseduncompressed-the-size-of-watdivdb-will-be-differentgenerally-increasing-if-using-du-h-command-to-check}{\paragraph{\texorpdfstring{In centos7, if the watdiv.db(a generated database after gload) is copied or compressed/uncompressed, the size of watdiv.db will be different(generally increasing) if using \texttt{du\ -h} command to check?}{In centos7, if the watdiv.db(a generated database after gload) is copied or compressed/uncompressed, the size of watdiv.db will be different(generally increasing) if using du -h command to check?}}\label{in-centos7-if-the-watdivdba-generated-database-after-gload-is-copied-or-compresseduncompressed-the-size-of-watdivdb-will-be-differentgenerally-increasing-if-using-du-h-command-to-check}}
%\hyperdef{}{in-centos7-if-the-watdivdba-generated-database-after-gload-is-copied-or-compresseduncompressed-the-size-of-watdivdb-will-be-differentgenerally-increasing-if-using-du-h-command-to-check}{\paragraph{\texorpdfstring{在centos7中，如果将watdiv.db（在gload之后生成的数据库）拷贝或压缩/解压，用\texttt{du\ -h}检查watdiv.db的大小会有所不同（通常是增加）？}{In centos7, if the watdiv.db(a generated database after gload) is copied or compressed/uncompressed, the size of watdiv.db will be different(generally increasing) if using du -h command to check?}}\label{in-centos7-if-the-watdivdba-generated-database-after-gload-is-copied-or-compresseduncompressed-the-size-of-watdivdb-will-be-differentgenerally-increasing-if-using-du-h-command-to-check}}
\quad\\
是watdiv/kv\_store/中B+-树大小的改变导致整个数据库大小的改变。原因是，在storage/Storage.cpp中，很多操作用fseek移动文件指针。大家都知道，文件是以块的形式组织的，如果我们请求新的块，文件指针可能移动到当前文件外（gStore中的文件操作都用C实现，没有报告错误），然后内容将写入新的位置！
%It's the change of B+-trees' size in watdiv/kv\_store/ that causes the change of the whole database's size. The reason is that in storage/Storage.cpp, many operations use fseek to move file pointer. As everyone knows, file is organized in blocks, and if we request for new block, file pointer may be moved beyond the end of this file(file operations are all achieved by C in gStore, no errors are reported), then contents will be written in the new position!

在\textbf{Unix环境下的高级编程}中，“文件洞”描述了这一现象。“文件洞”被0填充，也是文件的一部分。你可以用\texttt{ls\ -l} 查看文件的大小（计算了洞的大小），\texttt{du\ -h}命令显示目录/文件在系统中占用的块的大小。通常来说，\texttt{du\ -h} 的输出会比\texttt{du\ -h}更大，但如果“文件洞”存在，就会出现相反的结果，因为洞的大小被忽略了。
%In \textbf{Advanced Programming In The Unix Environment}, ``file hole'' is used to describe this phenomenon. ``file hole'' will be filled with 0, and it's also one part of the file. You can use \texttt{ls\ -l} to see the size of file(computing the size of holes), while \texttt{du\ -h} command shows the size of blocks that directory/file occupies in system. Generally, the output of \texttt{du\ -h} is large than that of \texttt{ls\ -l}, but if ``file hole'' exists, the opposite is the case because the size of holes are neglected.

包含洞的文件的实际大小被修正，在一些操作系统中，拷贝时洞会被转变为内容（也是0）。如果不是在不同的设备间，操作\texttt{mv}不会影响大小（只需要调整文件树索引）。然而，\texttt{cp}和各类压缩方法需要扫描文件并传输数据（考虑到是否忽略洞，有两种方法实现\texttt{cp}命令，但\texttt{ls\ -l}输出的大小不变）。
%The actual size of files containing holes are fixed, while in some operation systems, holes will be transformed to contents(also 0) when copied. Operation \texttt{mv} will not affect the size if not across different devices.(only need to adjust the file tree index) However, texttt{cp} and all kinds of compress methods need to scan the file and transfer data.(there are two ways to achieve \texttt{cp} command, neglect holes or not, while the output size of \texttt{ls\ -l} not varies)

在C中使用“文件洞”是有效的，这不是一个错误，你可以继续使用gStore。我们实现了一个小程序描述“文件洞“，你可以下载并尝试。
%It is valid to use ``file hole'' in C, and this is not an error, which means you can go on using gStore. We achieve a small program to describe the ``file holes'', you can download and try it yourself.

\hyperdef{}{in-gclient-console-a-database-is-built-queried-and-then-i-quit-the-console-next-time-i-enter-the-console-load-the-originally-imported-database-but-no-output-for-any-queriesoriginally-the-output-is-not-empty}{\paragraph{在gclient控制台中，生成并查询了一个数据库，然后我退出了控制台。下次我进入控制台时，加载原来载入的数据库，但没有任何查询的输出（原始输出不为空？}\label{in-gclient-console-a-database-is-built-queried-and-then-i-quit-the-console-next-time-i-enter-the-console-load-the-originally-imported-database-but-no-output-for-any-queriesoriginally-the-output-is-not-empty}}
%\hyperdef{}{in-gclient-console-a-database-is-built-queried-and-then-i-quit-the-console-next-time-i-enter-the-console-load-the-originally-imported-database-but-no-output-for-any-queriesoriginally-the-output-is-not-empty}{\paragraph{In gclient console, a database is built, queried, and then I quit the console. Next time I enter the console, load the originally imported database, but no output for any queries(originally the output is not empty)?}\label{in-gclient-console-a-database-is-built-queried-and-then-i-quit-the-console-next-time-i-enter-the-console-load-the-originally-imported-database-but-no-output-for-any-queriesoriginally-the-output-is-not-empty}}
\quad\\
在退出gclient控制台之前，你需要卸载数据库，否则会出现错误。
%You need to unload the using database before quiting the gclient console, otherwise errors come.

\hyperdef{}{if-query-results-contain-null-value-how-can-i-use-the-fulltest-utility-tab-separated-method-will-cause-problem-here-because-null-value-cannot-be-checked}{\paragraph{\texorpdfstring{如果查询结果包括null值，我要怎么使用\href{run:../../test/full_test.sh}{full\_test} 程序？用制表符分隔的方法会造成问题，因为不能检测到null值！}{If query results contain null value, how can I use the full\_test utility? Tab separated method will cause problem here because null value cannot be checked!}}\label{if-query-results-contain-null-value-how-can-i-use-the-fulltest-utility-tab-separated-method-will-cause-problem-here-because-null-value-cannot-be-checked}}
%\hyperdef{}{if-query-results-contain-null-value-how-can-i-use-the-fulltest-utility-tab-separated-method-will-cause-problem-here-because-null-value-cannot-be-checked}{\paragraph{\texorpdfstring{If query results contain null value, how can I use the \href{run:../../test/full_test.sh}{full\_test} utility? Tab separated method will cause problem here because null value cannot be checked!}{If query results contain null value, how can I use the full\_test utility? Tab separated method will cause problem here because null value cannot be checked!}}\label{if-query-results-contain-null-value-how-can-i-use-the-fulltest-utility-tab-separated-method-will-cause-problem-here-because-null-value-cannot-be-checked}}
\quad\\
你可使用其他编程语言（例如，Python）处理这种问题。例如，你可以在输出中将null值变为`,'之类的特殊字符，然后你就可以使用\href{run:../../test/full_test.sh}{full\_test} 了。
%You may use other programming language(for example, Python) to deal with the null value cases. For example, you can change null value in output to special character like `,', later you can use the \href{run:../../test/full_test.sh}{full\_test} utility.

\hyperdef{}{when-i-compile-and-run-the-api-examples-it-reports-the-unable-to-connect-to-server-error}{\paragraph{\texorpdfstring{当我编译并运行API样例时，报告``unable to connect to server''错误？}{When I compile and run the API examples, it reports the unable to connect to server error?}}\label{when-i-compile-and-run-the-api-examples-it-reports-the-unable-to-connect-to-server-error}}
%\hyperdef{}{when-i-compile-and-run-the-api-examples-it-reports-the-unable-to-connect-to-server-error}{\paragraph{\texorpdfstring{When I compile and run the API examples, it reports the ``unable to connect to server'' error?}{When I compile and run the API examples, it reports the unable to connect to server error?}}\label{when-i-compile-and-run-the-api-examples-it-reports-the-unable-to-connect-to-server-error}}
\quad\\
请先用\texttt{./gserver}命令启动gStore服务器，请注意服务器ip和端口号必须匹配。
%Please use \texttt{./gserver} command to start up a gStore server first, and notice that the server ip and port must be matched.

\hyperdef{}{when-i-use-the-java-api-to-write-my-own-program-it-reports-not-found-main-class-error}{\paragraph{\texorpdfstring{当我使用Java API写程序的时候，报告``not found main class'' 错误？}{When I use the Java API to write my own program, it reports not found main class error?}}\label{when-i-use-the-java-api-to-write-my-own-program-it-reports-not-found-main-class-error}}
%\hyperdef{}{when-i-use-the-java-api-to-write-my-own-program-it-reports-not-found-main-class-error}{\paragraph{\texorpdfstring{When I use the Java API to write my own program, it reports ``not found main class'' error?}{When I use the Java API to write my own program, it reports not found main class error?}}\label{when-i-use-the-java-api-to-write-my-own-program-it-reports-not-found-main-class-error}}
\quad\\
请确保你在java的类路径中包含了你的程序的位置。完整的命令应该和\texttt{java\ -cp\ /home/bookug/project/devGstore/api/java/lib/GstoreJavaAPI.jar:.\ JavaAPIExample}类似，命令中的``:.''不能省略。
%Please ensure that you include the position of your own program in class path of java. The whole command should be something like \texttt{java\ -cp\ /home/bookug/project/devGstore/api/java/lib/GstoreJavaAPI.jar:.\ JavaAPIExample}, and the ``:.'' in this command cannot be neglected.

%\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}
\clearpage
\hyperdef{}{chapter10}{\subsection{第10章：技巧}\label{chapter10}}
%\hyperdef{}{chapter10}{\subsection{Chapter 10: Recipe Book}\label{chapter10}}

\textbf{本章节介绍在使用gStore实现应用时的一些实用技巧。}
%\textbf{This chapter introduces some useful tricks if you are using gStore to implement applications.}

\emph{目前没有可用的提示}
%\emph{no tips available now}

\clearpage

\part{其他}
%\part{Others}

\hyperdef{}{chapter11}{\subsection{第11章：贡献者}\label{chapter11}}
%\hyperdef{}{chapter11}{\subsection{Chapter 11: Contributors}\label{chapter11}}

如果你对gStore有什么建议或意见，或者使用gStore时需要帮助，请与邹磊（zoulei@pku.edu.cn）、曾立（zengli-bookug@pku.edu.cn）、陈佳棋（chenjiaqi93@pku.edu.cn）和彭鹏（pku09pp@pku.edu.cn）联系。
%Please contact with Lei Zou(zoulei@pku.edu.cn), Li Zeng(zengli-bookug@pku.edu.cn), Jiaqi Chen(chenjiaqi93@pku.edu.cn) and Peng Peng(pku09pp@pku.edu.cn) if you have suggestions or comments about gStore or you need help when using gStore.

\hyperdef{}{faculty}{\paragraph{人员}\label{faculty}}
%\hyperdef{}{faculty}{\paragraph{Faculty}\label{faculty}}

\begin{itemize}
\item
  邹磊 （北京大学） 项目领导
  %Lei Zou (Peking University) Project Leader
\item
  M. Tamer {\"O}zsu （滑铁卢大学）
  %M. Tamer {\"O}zsu (University of Waterloo)
\item
  陈雷 （香港科技大学）
  %Lei Chen (Hong Kong University of Science and Technology)
\item
  赵东岩 （北京大学）
  %Dongyan Zhao (Peking Univeristy)
\end{itemize}

\hyperdef{}{students}{\paragraph{学生}\label{students}}
%\hyperdef{}{students}{\paragraph{Students}\label{students}}

\quad \\

\textit{曾立和陈佳棋负责gStore系统优化，彭鹏负责gStore的分布式版本，有望在十月之前发布。}
%\textit{Li Zeng and Jiaqi Chen are responsible for the gStore system optimization. Peng Peng is responsible for the distributed version of gStore, which is expected to be released before October.}

\begin{itemize}
\item
  彭鹏 （北京大学） （博士研究生）
  %Peng Peng (Peking University) (PhD student)
  %email: \href{mailto:pku09pp@pku.edu.cn}{pku09pp@pku.edu.cn}
\item
  李友焕 （北京大学） （博士研究生）
  %Youhuan Li (Peking University) (PhD student)
  %email: \href{mailto:liyouhuan@pku.edu.cn}{liyouhuan@pku.edu.cn}
\item
  韩硕 （北京大学） （博士研究生）
  %Shuo Han (Peking University) (PhD student)
  %email: \href{mailto:hanshuo@pku.edu.cn}{hanshuo@pku.edu.cn}
\item
  曾立 （北京大学） （硕士研究生）
  %Li Zeng (Peking University) (Master student)
  %email: \href{mailto:zengli-syzz@pku.edu.cn}{zengli-syzz@pku.edu.cn}
\item
  陈佳棋 （北京大学） （硕士研究一）
  %Jiaqi Chen (Peking University) (Master student)
  %email: \href{mailto:chenjiaqi93@pku.edu.cn}{chenjiaqi93@pku.edu.cn}
\end{itemize}

\hyperdef{}{alumni}{\paragraph{毕业生}\label{alumni}}
%\hyperdef{}{alumni}{\paragraph{Alumni}\label{alumni}}

\begin{itemize}
\item
  Xuchuan Shen （北京大学） （硕士研究生，已毕业）
  %Xuchuan Shen (Peking University) (Master's student, graduated)
  %email: \href{mailto:shenxuchuan@pku.edu.cn}{shenxuchuan@pku.edu.cn}
\item
  Dong Wang （北京大学） （博士研究生，已毕业）
  %Dong Wang (Peking University) (PhD student, graduated)
  %email: \href{mailto:wangdong@pku.edu.cn}{wangdong@pku.edu.cn}
\item
  Ruizhe Huang （北京大学） （本科实习生，已毕业）
  %Ruizhe Huang (Peking University) (Undergraudate intern, graduated)
\item
  Jinhui Mo （北京大学）（硕士研究生，已毕业）
  %Jinhui Mo (Peking University) (Master's, graduated)
\end{itemize}

\clearpage

\hyperdef{}{chapter12}{\subsection{第12章：更新日志}\label{chapter12}}
%\hyperdef{}{chapter12}{\subsection{Chapter 12: Updated Logs}\label{chapter12}}

\hyperdef{}{apr-01-2016}{\subsubsection{2016 年4月1日}\label{apr-01-2016}}
%\hyperdef{}{apr-01-2016}{\subsubsection{Apr 01, 2016}\label{apr-01-2016}}

这一项目的结构现在已经改变了很多。我们实现了一个新的连接方法，并取代了旧方法。测试结果显示，速度有所提升、内存消耗更低。我们还对Parser/Sparql*做了一些改变，都由ANTLR 生成。代码是用C实现的，因此必须做出一些修改，这带来了一些定义问题，还有就是它太大了。
%The structure of this project has changed a lot now. A new join method has been achieved and we use it to replace the old one. The test result shows that speed is improved and the memory cost is lower. We also do some change to Parser/Sparql*, which are all generated by ANTLR. They must be modified because the code is in C, which brings several multiple definition problems, and its size is too large.

原始的Stream模块中存在问题，会使结果中出现一些控制字符，例如\^{}C, \^{}V等等。我们现在修复了这一错误，使Stream能够对输出字符串进行排序（内部和外部都可以）。另外，使用本地方法，现在还支持非BGP（Basic Graph Pattern，基本图模式）的SPARQL查询。
%There is a bug in the original Stream module, which brings some control characters to the output, such as \^{}C, \^{}V and so on. We have fixed it now and enabled the Stream to sort the output strings(both internal and external). In addition, SPARQL queries which are not BGP(Basic Graph Pattern) are also supported now, using the naive method.

我们实现了强大的交互式控制台，称为\texttt{gconsole}，方便了使用者。此外，我们用valgrind工具测试我们的结果，处理了一些内存泄露问题。
%A powerful interactive console, which is named \texttt{gconsole} now, is achieved to bring convenience to users. What is more, we use valgrind tools to test our system, and deal with several memory leaks.

文档和API也做了更改，这一点比较不重要。
%The docs and API have also changed, but this is of little importance.

\hyperdef{}{nov-06-2015}{\subsubsection{2015 年11月6日}\label{nov-06-2015}}
%\hyperdef{}{nov-06-2015}{\subsubsection{Nov 06, 2015}\label{nov-06-2015}}

我们合并了一些类（例如Bstr）并调整了项目结构和调试系统。
%We merge several classes(like Bstr) and adjust the project structure, as well as the debug system.

另外，我们移除了大部分警告，除了Parser模块下的警告，它们是由于使用ANTLR出现的。
%In addition, most warnings are removed, except for warnings in Parser module, which is due to the use of ANTLR.

此外，我们将RangeValue模块改为Stream模块，并为ResultSet添加了Stream。我们还优化了gquery控制台，现在你可以在gsql控制台将查询结果重新定向至指定的文件。
%What is more, we change RangeValue module to Stream, and add Stream for ResultSet. We also better the gquery console, so now you can redirect query results to a specified file in the gsql console.

由于操作复杂，我们不能在IDlist中添加Stream，但这不是必需的。Realpath被用于支持gquery控制台中的软件连接，但在Gstore中不起作用（如果不是Gstore将会起作用）。
%Unable to add Stream for IDlist due to complex operations, but this is not necessary. Realpath is used to supported soft links in the gquery console, but it not works in Gstore.(though works if not in Gstore)

\hyperdef{}{oct-20-2015}{\subsubsection{2015 年10月20日}\label{oct-20-2015}}
%\hyperdef{}{oct-20-2015}{\subsubsection{Oct 20, 2015}\label{oct-20-2015}}

我们新增了一个gtest工具，你可以使用它查询数据集。
%We add a gtest tool for utility, you can use it to query several datasets with their own queries.

另外，我们优化了gquery控制台。Readline库被用于输入，而不是fgets，现在gquery控制台可以支持历史命令、修改命令和完成命令。
%In addition, gquery console is improved. Readline lib is used for input instead of fgets, and the gquery console can support commands history, modifying command and commands completion now.

此外，我们发现并修复了Database/中的一个错误（用于调试日志的指针在fclose操作后没的被设置为NULL，所以如果你关闭一个数据集再打开另一个数据集，系统会无法工作，因为系统认为调试日志还处于打开状态）。
%What is more, we found and fix a bug in Database/(a pointer for debugging log is not set to NULL after fclose operation, so if you close one database and open another, the system will fail entirely because the system think that the debugging log is still open)

\hyperdef{}{sep-25-2015}{\subsubsection{2015 年9月25日}\label{sep-25-2015}}
%\hyperdef{}{sep-25-2015}{\subsubsection{Sep 25, 2015}\label{sep-25-2015}}

我们完成了B+树的版本，取代了旧版本。
%We implement the version of B+Tree, and replace the old one.

在测试了DBpedia，LUBM和WatDiv benchmark 后，我们得出结论，新的B树比旧版本更高效。对于相同的三元组文件，新版本在执行gload指令上花费的时间更少。
%After testing on DBpedia, LUBM, and WatDiv benchmark, we conclude that the new BTree performs more efficient than\\ the old version. For the same triple file, the new version spends shorter time on executing gload command.

另外，新版本可以有效地处理长文本客体，三元组的客体长度超过4096字节在旧版本的B树上会导致频繁的无效分隔操作。
%Besides, the new version can handle the long literal objects efficiently, while triples whose object's length exceeds 4096 bytes result in frequent inefficient split operations on the old version BTree.

\hyperdef{}{feb-2-2015}{\subsubsection{2015 年2月2日}\label{feb-2-2015}}
%\hyperdef{}{feb-2-2015}{\subsubsection{Feb 2, 2015}\label{feb-2-2015}}

我们修改了RDF解析和SPARQL解析。
%We modify the RDF parser and SPARQL parser.

在新的RDF解析中，我们重新设计了编码策略，减少了RDF文件的扫描次数。
%Under the new RDF parser, we also redesign the encode strategy, which reduces RDF file scanning times.

现在我们可以正确解析标准SPARQL v1.1的语法，并可以支持用这一标准语法写成的基本图模式（BGP）SPARQL查询。
%Now we can parse the standard SPARQL v1.1 grammar correctly, and can support basic graph pattern(BGP) SPARQL queries written by this standard grammar.

\hyperdef{}{dec-11-2014}{\subsubsection{2014 年12月11日}\label{dec-11-2014}}
%\hyperdef{}{dec-11-2014}{\subsubsection{Dec 11, 2014}\label{dec-11-2014}}

我们添加了C/CPP和JAVA的API。
%We add API for C/CPP and JAVA.

\hyperdef{}{nov-20-2014}{\subsubsection{2014 年11月20日}\label{nov-20-2014}}
%\hyperdef{}{nov-20-2014}{\subsubsection{Nov 20, 2014}\label{nov-20-2014}}

我们将gStore作为一个遵循BSD协议的开源软件，在github上分享了gStore2.0的代码。
%We share our gStore2.0 code as an open-source project under BSD license on github.

\clearpage

\hyperdef{}{chapter13}{\subsection{第13章：测试结果}\label{chapter13}}
%\hyperdef{}{chapter13}{\subsection{Chapter 13: Test Result}\label{chapter13}}

\hyperdef{}{preparation}{\subsubsection{准备工作}\label{preparation}}
%\hyperdef{}{preparation}{\subsubsection{Preparation}\label{preparation}}

我们比较了gStore和其他几个数据库系统的性能，例如\href{http://jena.apache.org/}{Jena}、\href{http://www.rdf4j.org/}{Sesame}、\href{http://virtuoso.openlinksw.com/}{Virtuoso} 等等。比较的内容是建立数据库的时间、建立的数据库大小、回答单个SPARQL查询的时间和单个查询结果的匹配。另外，如果内存开销很大（\textgreater{}20G），我们会在运行数据库系统时记录内存开销（不准确，仅用于参考）。\\
%We have compared the performance of gStore with several other database systems, such as \href{http://jena.apache.org/}{Jena}, \href{http://www.rdf4j.org/}{Sesame}, \href{http://virtuoso.openlinksw.com/}{Virtuoso} and so on. Contents to be compared are the time to build database, the size of the built database, the time to answer single SPARQL query and the matching case of single query's results. In addition, if the memory cost is very large(\textgreater{}20G), we will record the memory cost when running these database systems.(not accurate, just for your reference) \\

为了确保所有的数据库系统都能正确运行所有的数据集和查询，数据集的格式必须能由全部数据库系统支持，查询不应包括更新操作、聚集操作和与不确定谓词相关的操作。请注意，在测试回答查询所用的时间时，加载数据库的时间不计算在内。为了确保这一原则，我们先为一些数据库系统加载数据库索引，并为其他系统做准备。\\
%To ensure all database systems can run correctly on all datasets and queries, the format of datasets must be supported by all database systems and the queries should not contain update operations, aggregate operations and operations related with uncertain predicates. Notice that when measuring the time to answer queries, the time of loading database index should not be included. To ensure this principle, we load the database index first for some database systems, and warm up several times for others. \\

这里使用的数据集是WatDiv，Lubm，Bsbm和DBpedia。一些由网站提供，另外的由算法生成。查询由算法生成或者是我们自己写的。表\ref{table:datasets}总结了这些数据集的统计信息。
%Datasets used here are WatDiv, Lubm, Bsbm and DBpedia. Some of them are provided by websites, and others are generated by algorithms. Queries are generated by algorithms or written by us. Table \ref{table:datasets} summarizes the statistics of these datasets.

实现环境是CentOS服务器，内存大小为82G，硬盘大小为7T，我们使用\href{run:../../test/full_test.sh}{full\_test} 进行测试。
%The experiment environment is a CentOS server, whose memory size is 82G and disk size is 7T. We use \href{run:../../test/full_test.sh}{full\_test} to do this test.

\begin{table}[b]
	\small
	\centering
	%\vspace{-0.1in}
	\caption{数据集}
    %\caption{Datasets}
	\begin{tabular}{|c|c|r|r|r|}
		\hline
		数据集& 三元组数量& RDF N3文件大小（B） & 实体数量\\
        %Dataset& Number of Triples& RDF N3 File Size(B)  & Number of Entities\\
		\hline
		\hline
		%WatDiv 10M & 109,164,587 & 1542624409 & 0 \\
		%\hline
		%WatDiv 100M & 108,997,714 & 15,599,074,048 & 5,212,745 \\
		%\hline
        WatDiv 300M & 329,539,576  & 47,670,221,085 & 15,636,385 \\
		\hline
		%LUBM 500 & 6652613 & 801112089 & 1648692 \\
		%\hline
		LUBM 5000 & 66718642 & 8134671485 & 16437950 \\
		\hline
		DBpedia 2014 & 170784508 & 23844158944 & 7123915 \\
		\hline
		Bsbm 10000 & 34872182 & 912646084  & 526590 \\
		\hline
	\end{tabular}
	%  \vspace{-0.1in}
	\label{table:datasets}
\end{table}

%BETTER:using bsbm_100000?

\hyperdef{}{result}{\subsubsection{结果}\label{result}}
%\hyperdef{}{result}{\subsubsection{Result}\label{result}}

\begin{comment}
Table \ref{table:loading} shows the index size and loading time of the datasets for different systems.

\begin{table}[htcp]
\small
\begin{threeparttable}
\begin{tabular}{|c||c|c|c||c|c|c|}
\hline
 & \multicolumn{3}{c||}{Index Size(KB)}& \multicolumn{3}{c|}{Loading Time(second)}\\
\hline
\hline
 Datasets & gStore & Jena& Virtuoso& gStore & Jena& Virtuoso\\
  \hline
  DBpedia 2014 & 42,415,852&	23,151,272 &	-\tnote{$1$} & 8,639,666	&15,555,000	& -	\\
  \hline
  Bsbm 10000 & 1,814,480 & 718,024 & 2,080,000 & 244,153 & 76,000 & 59999  \\
  \hline
  LUBM 500  &2,171,084 &1,022,528	&	38,000,000 &	291,382&	94,000 &100,532	 \\
  \hline
  %LUBM 5000 & 23,397,548&	10,262,524	 &	- & 3,767,764	&1,098,000  &	- \\
   %\hline
  %WatDiv 10M & 2,563,168&	1,315,764	 &	10,320,000 & 532,542	&304,000	&225,464 \\
  %\hline
  WatDiv 100M & 26,566,780&	13,286,608	 &	8,615,100 & 7,879,602	&20,969,000	&16,981,470 \\
  \hline
  %WatDiv 300M & 80,166,500&	38,108,940	 &	- & 19,864,431	&25,041,000 &	- \\
  %\hline
  \end{tabular}
    \begin{tablenotes}
  \small
  \item[$1$] ``-'' means that loading does not terminate in 10 hour
  \end{tablenotes}
  \end{threeparttable}
  \caption{Offline Performance}
  \label{table:loading}
\end{table}
\end{comment}

不同数据库管理系统的性能在图\ref{fig:dbpedia2014Performance}，\ref{fig:BsbmPerformance}，\ref{fig:LUBMPerformance}，\ref{fig:WatDivPerformance}中显示。
%The performance of different database management systems is shown in Figures \ref{fig:dbpedia2014Performance}, \ref{fig:BsbmPerformance}, \ref{fig:LUBMPerformance} and \ref{fig:WatDivPerformance}.

注意，Sesame和Virtuoso无法对DBpedia 2014和WatDiv 300M进行操作，因为数据集太大。另外，由于格式问题，我们不使用Sesame和Virtuoso 测试LUBN 5000。总的来说，Virtuoso 不可测量，Sesame太弱。
%Notice that Sesame and Virtuoso are unable to operate on DBpedia 2014 and WatDiv 300M, because the size is too large. In addition, we do not use Sesame and Virtuoso to test on the LUBM 5000 due to format questions. Generally speaking, Virtuoso is not scalable, and Sesame is so weak. \\

\begin{figure}[b]%
		\resizebox{0.48\columnwidth}{!}{
			\input{dbpedia2014_comparison}
		}
 \caption{DBpedia 2014查询性能}%
 %\caption{Query Performance over DBpedia 2014}%
 \label{fig:dbpedia2014Performance}
\end{figure}

\begin{figure}%
		\resizebox{0.8\columnwidth}{!}{
			\input{bsbm_comparison}
		}
 \caption{Bsbm 10000查询性能}%
 %\caption{Query Performance over Bsbm 10000}%
 \label{fig:BsbmPerformance}
\end{figure}

\begin{figure}[h]%
   %\subfigure[LUBM 500]{%
		%\resizebox{0.98\columnwidth}{!}{
			%\input{LUBM500_comparison}
		%}
       %\label{fig:LUBM500Performance}%
       %}
       %\\
\subfigure[LUBM 5000]{%
		\resizebox{0.98\columnwidth}{!}{
			\input{LUBM5000_comparison}
		}
	   \label{fig:LUBM5000Performance}%
	   }%
 \caption{LUBM查询性能}%
 %\caption{Query Performance over LUBM}%
 \label{fig:LUBMPerformance}
\end{figure}

\begin{figure}[h]%
 %\subfigure[WatDiv 10M]{%
		%\resizebox{0.8\columnwidth}{!}{
			%\input{WatDiv10M_comparison}
		%}
       %\label{fig:WatDiv10MPerformance}%
       %}
   %\subfigure[WatDiv 100M]{%
		%\resizebox{0.8\columnwidth}{!}{
			%\input{WatDiv100M_comparison}
		%}
       %\label{fig:WatDiv100MPerformance}%
       %}
\subfigure[WatDiv 300M]{%
		\resizebox{0.8\columnwidth}{!}{
			\input{WatDiv300M_comparison}
		}
	   \label{fig:WatDiv300MPerformance}%
	   }%
 \caption{WatDiv性能}%
 %\caption{Query Performance over WatDiv}%
 \label{fig:WatDivPerformance}
\end{figure}

这一程序产生的大量日志存放在result.log/，load.log/和time.log/中。看一下result.log/ 中的文件，会发现所有的查询结果都是匹配的，load.log/中的文件显示，gStore新建数据库的时间开销和空间开销大于其他系统。更准确地说，在新建数据库时，gStore 和其他系统的时间/空间开销存在量级差。
%This program produces many logs placed in result.log/, load.log/ and time.log/. You can see that all results of all queries are matched by viewing files in result.log/, and the time cost and space cost of gStore to build database are larger than others by viewing files in load.log/. More precisely, there is an order of magnitude difference between gStore and others in the time/space cost of building database.

通过分析time.log/，我们会发现在复杂查询上（多变量、圈等等），gStore比其他系统表现更好。对于其他简单查询，这些数据库系统所用的时间没有太大差异。
%Through analysing time.log/, we can find that gStore behave better than others on very complicated queries(many variables, circles, etc). For other simple queries, there is not much difference between the time of these database systems.

总的来说，回答查询时gStore的内存开销比其他系统更高。查询越复杂、数据集越大，这一现象越明显。
%Generally speaking, the memory cost of gStore when answering queries is higher than others. More complicated the query is and more large the dataset is, more apparent the phenomenon is.

你可以在\href{run:../pdf/gstore_test_report.pdf}{原始实验报告}中找到更详细的信息。请注意，实验报告中的一些问题现在已经得到了解决。
%You can find more detailed information in \href{run:../pdf/gstore_test_report.pdf}{original test report}. Notice that some questions in the test report have already be solved now.
最新版的实验报告是\href{run:../latex/formal_experiment.pdf}{正式实验}。
%The latest test report is \href{run:../latex/formal_experiment.pdf}{formal experiment}.

\clearpage

\hyperdef{}{chapter14}{\subsection{第14章：将来计划}\label{chapter14}}
%\hyperdef{}{chapter14}{\subsection{Chapter 14: Future Plan}\label{chapter14}}

\hyperdef{}{improve-the-core}{\subsubsection{提升核心}\label{improve-the-core}}
%\hyperdef{}{improve-the-core}{\subsubsection{Improve The Core}\label{improve-the-core}}

\begin{itemize}
\item
  优化候选结点的连接操作。应该实现多种方法，并设计一个评分模块选择最好的方法
  %optimize the join operation of node candidates. multiple methods should be achieved, and design a score module to select a best one
\item
  添加数值查询函数。需要高效回答数值范围查询，空间消耗不能太大
  %add numeric value query function. need to answer numeric range query efficiently and space consume cannot be too large
\item
  添加控制模块，启发式地为一条SPARQL查询选择一种索引（不总是vstree）
  %add a control module to heuristically select an kind of index for a SPARQL query to filter(not always vstree)
\item
  定义所有常用的类型，避免不一致和高修改代价
  %typedef all frequently used types, to avoid inconsistence and high modify cost
\end{itemize}

\hyperdef{}{better-the-interface}{\subsubsection{优化接口}\label{better-the-interface}}
%\hyperdef{}{better-the-interface}{\subsubsection{Better The Interface}\label{better-the-interface}}

\begin{itemize}
\item
  建立一个称为gconsole的控制台，提供gStore支持的所有操作（需要解析器和自动完成）
  %build a console named gconsole, which provides all operations supported by gStore.(parser and auto-complete is required)
\item
  写一个gStore的网络接口和操作用的网页，就像virtuoso一样
  %write web interface for gStore, and a web page to operate on it, just like virtuoso
\end{itemize}

\hyperdef{}{idea-collection-box}{\subsubsection{意见收集箱}\label{idea-collection-box}}
%\hyperdef{}{idea-collection-box}{\subsubsection{Idea Collection Box}\label{idea-collection-box}}

\begin{itemize}
\item
  支持控制台的软件连接：realpath不起作用\ldots{}（在ANTLR中重新定义？）
  %to support soft links in console: realpath not work\ldots{}(redefined in ANTLR?)
\item
  为控制台存储历史指令
  %store command history for consoles
\item
  使用Parser/(antlr)!(modify sparql.g 1.1 and regenerate)时还会有警告信息.改变名称，避免重新定义问题，或者使用可执行程序解析
  %warnings remain in using Parser/(antlr)!(modify sparql.g 1.1 and regenerate). change name to avoid redefine problem, or go to use executable to parse
\item
  生成压缩模块（例如键-值模块和流模块），但后者只需要一次读/写，可能导致硬盘和内存中都使用压缩方法。所有对内存中字符串的操作都可以改成压缩后的操作：提供压缩/获取接口、比较函数。有很多压缩算法可供选择，那么如何选择？utf-8编码的问题怎么处理？这一方法可以降低内存和硬盘开销，但会占用更多CPU。然而，时间取决于同构。简单压缩不是很好，但过于复杂的压缩方法会花费太多时间，如何权衡？（合并连续的相同字符，哈夫曼树）
  %build compress module(such as key-value module and stream module), but the latter just needs one-pass read/write, which may causes the compress method to be used both in disk and memory. all operations of string in memory can be changed to operations after compress: provide compress/archive interface, compare function. there are many compress algorithms to be chosen, then how to choose? what about utf-8 encoding problem? this method can lower the consume of memory and disk, but consumes more CPU. However, the time is decided by isomorphism. Simple compress is not good, but too complicated method will consume too much time, how to balance? (merge the continuous same characters, Huffman tree)
\item
  用mmap加速KVstore？
  %mmap to speedup KVstore?
\item
  Stream的策略：85\%有效吗？考虑到抽样，分析结果集的大小再决定策略？如何支持：没有存入文件时在内存中排序；否则，在内存中部分排序，然后存入文存，再进行外部排序。
  %the strategy for Stream:is 85\% valid? consider sampling, analyse the size of result set and decide strategy? how to support order by: sort in memory if not put in file; otherwise, partial sort in memory, then put into file, then proceed external sorting
\end{itemize}

\clearpage

\hyperdef{}{chapter15}{\subsection{第15章：致谢列表}\label{chapter15}}
%\hyperdef{}{chapter15}{\subsection{Chapter 15: Thanks List}\label{chapter15}}

\textit{本章列出了启发我们或为项目做出贡献的人}
%\textit{This chapter lists people who inspire us or contribute to this project.}

\emph{目前还没有人}
%\emph{nobody now}

%\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}
\clearpage

\hyperdef{}{chapter16}{\subsection{第16章：法律问题}\label{chapter16}}
%\hyperdef{}{chapter16}{\subsection{Chapter 16: Legal Issues}\label{chapter16}}

%\textbf{We are trying our best to avoid errors. However, if you encounter any unrecovable disaster when using this system, we shall not be responsible for it.}

%below is the BSD LICENSE: http://baike.baidu.com/link?url=a7XUsshp1Sd_DvF7oIJ_CpHTOZryu4ACSSj1AyQl1GU9XL5pPEj9RxIEMF1nC213VvJ2quhWTK9OCZot-CS0LK
%The following is a BSD license template. To generate your own license, change the values of OWNER, ORGANIZATION and YEAR from their original values as given here, and substitute your own.
%Note: The advertising clause in the license appearing on BSD Unix files was officially rescinded by the Director of the Office of Technology Licensing of the University of California on July 22 1999. He states that clause 3 is "hereby deleted in its entirety."
%Note the new BSD license is thus equivalent to the MIT License, except for the no-endorsement final clause.
%<OWNER> = gStore team
%<ORGANIZATION> = Peking University
%<YEAR> = 2016
%In the original BSD license, both occurrences of the phrase "COPYRIGHT HOLDERS AND CONTRIBUTORS" in the disclaimer read "REGENTS AND CONTRIBUTORS".
%Here is the license template:
%Copyright (c) &lt;YEAR&gt;, &lt;OWNER&gt;

版权所有(c) 2016 gStore团队 \\
%Copyright (c) 2016 gStore team \\
保留所有权利。\\
%All rights reserved. \\

在遵守以下条件的前提下，可以源代码及二进制形式再发布或使用软件，包括进行修改或不进行修改：
%Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

源代码的再发布必须保持上述版权通知，本条件列表和以下声明。
%Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

以二进制形式再发布软件时必须在文档和/或发布提供的其他材料中复制上述版权通知，本条件列表和以下声明。
%Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

未经事先书面批准的情况下，不得交f北京大学或贡献者的名字用于支持或推广该软件的衍生产品。\\
%Neither the name of the Peking University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \\

本软件为版权所有人和贡献者“按现状”为根据提供，不提供任何明确或暗示的保证，包括但不限于本软件针对特定用途的可售性及适用性的暗示保证。在任何情况下，版权所有人或其贡献者均不对因使用本软件而以任何方式产生的任何直接、间接、偶然、特殊、典型或因此而生的损失（包括但不限于采购替换产品或服务；使用价值、数据或利润的损失；或业务中断）而根据任何责任理论，包括合同、严格责任或侵权行为（包括疏忽或其他）承担任何责任，即使在已经提醒可能发生此类损失的情况下。\\
%THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \\

另外，在使用gStore了的软件产品中，你需要包含“powered by gStore”标签和gStore的图标。
%What's more, you need to include the label "powered by gStore", as well as the logo of gStore, in your software product which is using gStore.

如果你愿意告诉我们你的姓名、机构、目的和邮箱，我们非常感激。可以发邮件至\href{mailto:gStoreDB@gmail.com}{gStoreDB@gmail.com}将这些信息发送给我们，我们保证不会泄露隐私。
%We would be very grateful if you are willing to tell us about your name, institution, purpose and email.  Such information can be sent to us by emailing to \href{mailto:gStoreDB@gmail.com}{gStoreDB@gmail.com}, and we promise not to reveal privacy.
%using gmail or website

\clearpage

\section{结语}
%\section{End}
\textbf{感谢你阅读这一文档。如果有任何问题或意见，或者对这一项目有兴趣，请与我们联系。}
%\textbf{Thank you for reading this document. If any question or advice, or you have interests in this project, please don't hesitate to get in touch with us.}

\clearpage

\end{document}

